From 76e101440f703b7973021b8b348aaca73cea247d Mon Sep 17 00:00:00 2001
From: Black-Seraph <admin@black-seraph.com>
Date: Thu, 4 May 2023 10:39:17 +0200
Subject: [PATCH 1/2] Rotate screen clockwise

---
 src/video/kmsdrm/SDL_kmsdrmmisc.c  |  5 +++
 src/video/kmsdrm/SDL_kmsdrmvideo.c | 53 +++++++++++++++++++++++++++---
 src/video/kmsdrm/SDL_kmsdrmvideo.h |  4 ++-
 3 files changed, 57 insertions(+), 5 deletions(-)

diff --git a/src/video/kmsdrm/SDL_kmsdrmmisc.c b/src/video/kmsdrm/SDL_kmsdrmmisc.c
index 96ea0a2e..c1317a4e 100644
--- a/src/video/kmsdrm/SDL_kmsdrmmisc.c
+++ b/src/video/kmsdrm/SDL_kmsdrmmisc.c
@@ -69,6 +69,11 @@ int KMSDRM_LookupVidMode(_THIS, int width, int height)
 
 void KMSDRM_RegisterVidMode(_THIS, int width, int height)
 {
+	// Turn 480x640 into 640x480
+	int tmp = width;
+	width = height;
+	height = tmp;
+
 	if (KMSDRM_LookupVidMode(this, width, height) >= 0) {
 		return;
 	}
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.c b/src/video/kmsdrm/SDL_kmsdrmvideo.c
index db6d6247..dd9f67a9 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.c
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.c
@@ -155,6 +155,8 @@ int KMSDRM_VideoInit(_THIS, SDL_PixelFormat *vformat)
 	drm_vid_modes = SDL_realloc(drm_vid_modes, sizeof(*drm_vid_modes) * (drm_vid_mode_count+1));
 	drm_vid_modes[0] = NULL;
 
+	uint32_t maxWidth = 0;
+	uint32_t maxHeight = 0;
 	for (int plane_idx = 0; plane_idx < pres->count_planes; plane_idx++) {
 		drmModePlane *plane = drmModeGetPlane(drm_fd, pres->planes[plane_idx]);
 		if ( !plane ) {
@@ -174,6 +176,12 @@ int KMSDRM_VideoInit(_THIS, SDL_PixelFormat *vformat)
 			     conn->connection == DRM_MODE_CONNECTED &&
 			     conn->count_modes > 0 ) {
 				// This is a complete, suitable pathway. save it.
+				if (maxWidth < crtc->width) {
+					maxWidth = crtc->width;
+				}
+				if (maxHeight < crtc->height) {
+					maxHeight = crtc->height;
+				}
 				save_drm_pipe(this, plane->plane_id, crtc->crtc_id,
 					      enc->encoder_id, conn);
 			}
@@ -322,12 +330,17 @@ static void KMSDRM_ClearFramebuffers(_THIS)
 
 static void KMSDRM_ClearShadowbuffer(_THIS)
 {
-	if ( drm_shadow_buffer ) {
+	if (drm_shadow_buffer) {
 		free(drm_shadow_buffer);
 		free(drm_yuv_palette);
 		drm_shadow_buffer = NULL;
 		drm_yuv_palette = NULL;
 	}
+
+	if (drm_rotate_buffer) {
+		free(drm_rotate_buffer);
+		drm_rotate_buffer = NULL;
+	}
 }
 
 static int KMSDRM_VideoModeOK(_THIS, int width, int height, int bpp, Uint32 flags)
@@ -418,6 +431,11 @@ static SDL_Surface *KMSDRM_SetVideoMode2(_THIS, SDL_Surface *current,
 	SDL_Surface *new_surface;
 	drmModeModeInfo *closest_mode;
 
+	// Turns 640x480 into 480x640
+	int tmp = width;
+	width = height;
+	height = tmp;
+
 	// Lock the event thread, in multi-threading environments
 	SDL_Lock_EventThread();
 
@@ -460,6 +478,8 @@ static SDL_Surface *KMSDRM_SetVideoMode2(_THIS, SDL_Surface *current,
 		drm_yuv_palette = calloc(1 << bpp, sizeof(*drm_yuv_palette));
 	}
 
+	drm_rotate_buffer = calloc(width * height, bpp / 8);
+
 	// Get rounded bpp number for drm_mode_create_dumb.
 	const drm_color_def *color_def = get_drm_color_def(bpp, flags);
 	if ( !color_def ) {
@@ -582,9 +602,10 @@ static SDL_Surface *KMSDRM_SetVideoMode2(_THIS, SDL_Surface *current,
 		current->pixels = drm_shadow_buffer;
 	}
 
-	current->w = width;
-	current->h = height;
-	current->pitch = drm_buffers[0].req_create.pitch;
+	// Turn 480x640 into 640x480
+	current->w = height;
+	current->h = width;
+	current->pitch = height * current->format->BytesPerPixel;
 
 	this->hidden->has_damage_clips = find_property(this, drm_active_pipe->plane,
 						       "FB_DAMAGE_CLIPS");
@@ -793,6 +814,27 @@ static void KMSDRM_BlitSWBuffer(_THIS, drm_buffer *buf)
 			  this->hidden->w * this->hidden->h);
 }
 
+static void KMSDRM_RotateSurface(_THIS, SDL_Surface *surface)
+{
+	if (SDL_MUSTLOCK(surface)) {
+		SDL_LockSurface(surface);
+	}
+	int w = surface->w;
+	int h = surface->h;
+	int p = surface->pitch;
+	uint32_t* pixels = (uint32_t*)surface->pixels;
+	uint32_t* mirror = (uint32_t*)drm_rotate_buffer;
+	memcpy(mirror, pixels, p * h);
+	for (int i = 0; i < h; i++) {
+		for (int j = 0; j < w; j++) {
+			pixels[j * h + (h - i - 1)] = mirror[i * w + j];
+		}
+	}
+	if (SDL_MUSTLOCK(surface)) {
+		SDL_UnlockSurface(surface);
+	}
+}
+
 static int KMSDRM_FlipHWSurface(_THIS, SDL_Surface *surface)
 {
 	if ( !drm_active_pipe )
@@ -803,6 +845,9 @@ static int KMSDRM_FlipHWSurface(_THIS, SDL_Surface *surface)
 		KMSDRM_BlitSWBuffer(this, &drm_buffers[drm_back_buffer]);
 	}
 
+	// Rotate the surface
+	KMSDRM_RotateSurface(this, surface);
+
 	// Either wait for VSync or for buffer acquire
 	if ( (surface->flags & SDL_TRIPLEBUF) == SDL_DOUBLEBUF ) {
 		drmModeAtomicReqPtr req = drmModeAtomicDuplicate(this->hidden->drm_req);
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.h b/src/video/kmsdrm/SDL_kmsdrmvideo.h
index 3ab858ec..744040b9 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.h
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.h
@@ -110,7 +110,8 @@ struct SDL_PrivateVideoData {
 	Uint32 size;
 	Uint32 handle;
 	void *map;
-    Uint8 *shadow_buffer;
+	Uint8 *shadow_buffer;
+	Uint8 *rotate_buffer;
 
     drm_pipe *first_pipe;
     drm_pipe *active_pipe;
@@ -145,6 +146,7 @@ struct SDL_PrivateVideoData {
 #define drm_handle           (this->hidden->handle)
 #define drm_map              (this->hidden->map)
 #define drm_shadow_buffer    (this->hidden->shadow_buffer)
+#define drm_rotate_buffer    (this->hidden->rotate_buffer)
 #define drm_first_pipe       (this->hidden->first_pipe)
 #define drm_first_prop_store (this->hidden->first_prop_store)
 #define drm_buffers          (this->hidden->buffers)
-- 
2.25.1

