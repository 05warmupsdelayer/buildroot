From d4a7d020ef7b22b2cdd3800e7680a5063a7fecba Mon Sep 17 00:00:00 2001
From: Black-Seraph <admin@black-seraph.com>
Date: Wed, 3 May 2023 15:53:05 +0200
Subject: [PATCH] Commonize tinyalsa driver

---
 audio/drivers/tinyalsa.c                      | 2489 ++--------------
 ...-make-compiler-variable-overwritable.patch |   53 +
 .../0002-Commonize-tinyalsa-driver.patch      | 2586 +++++++++++++++++
 ...0003-Add-hotkey-tap-controller-combo.patch |  165 ++
 .../retroarch/0004-Add-shutdown-hotkey.patch  |  255 ++
 .../0005-Add-garlicui_run-hooks.patch         |   95 +
 .../0006-Implement-Scaling-Options.patch      |  243 ++
 .../retroarch/0007-Ignore-NULL-frames.patch   |   25 +
 ...o-savestate-thumbnails-synchronously.patch |   28 +
 .../0009-Don-t-restart-MMAP-soundcards.patch  |  138 +
 oldpatches/retroarch/Config.in                |  153 +
 oldpatches/retroarch/Internal Gamepad.cfg     |   43 +
 oldpatches/retroarch/retroarch.mk             |  219 ++
 13 files changed, 4187 insertions(+), 2305 deletions(-)
 create mode 100644 oldpatches/retroarch/0001-make-compiler-variable-overwritable.patch
 create mode 100644 oldpatches/retroarch/0002-Commonize-tinyalsa-driver.patch
 create mode 100644 oldpatches/retroarch/0003-Add-hotkey-tap-controller-combo.patch
 create mode 100644 oldpatches/retroarch/0004-Add-shutdown-hotkey.patch
 create mode 100644 oldpatches/retroarch/0005-Add-garlicui_run-hooks.patch
 create mode 100644 oldpatches/retroarch/0006-Implement-Scaling-Options.patch
 create mode 100644 oldpatches/retroarch/0007-Ignore-NULL-frames.patch
 create mode 100644 oldpatches/retroarch/0008-Write-auto-savestate-thumbnails-synchronously.patch
 create mode 100644 oldpatches/retroarch/0009-Don-t-restart-MMAP-soundcards.patch
 create mode 100644 oldpatches/retroarch/Config.in
 create mode 100644 oldpatches/retroarch/Internal Gamepad.cfg
 create mode 100644 oldpatches/retroarch/retroarch.mk

diff --git a/audio/drivers/tinyalsa.c b/audio/drivers/tinyalsa.c
index fee4174..77fa286 100644
--- a/audio/drivers/tinyalsa.c
+++ b/audio/drivers/tinyalsa.c
@@ -1,31 +1,3 @@
-/* pcm.c
-**
-** Copyright 2011, The Android Open Source Project
-**
-** Redistribution and use in source and binary forms, with or without
-** modification, are permitted provided that the following conditions are met:
-**     * Redistributions of source code must retain the above copyright
-**       notice, this list of conditions and the following disclaimer.
-**     * Redistributions in binary form must reproduce the above copyright
-**       notice, this list of conditions and the following disclaimer in the
-**       documentation and/or other materials provided with the distribution.
-**     * Neither the name of The Android Open Source Project nor the names of
-**       its contributors may be used to endorse or promote products derived
-**       from this software without specific prior written permission.
-**
-** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
-** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
-** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-** DAMAGE.
-*/
-
 /*  RetroArch - A frontend for libretro.
  *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
  *  Copyright (C) 2011-2017 - Daniel De Matteis
@@ -64,2346 +36,253 @@
 #include <retro_inline.h>
 #include <retro_endianness.h>
 
+#include <sound/asound.h>
+#include <tinyalsa/asoundlib.h>
+
 #include "../audio_driver.h"
 #include "../../verbosity.h"
 
-/* Implementation tinyalsa pcm */
-
-/** A flag that specifies that the PCM is an output.
- * May not be bitwise AND'd with @ref PCM_IN.
- * Used in @ref pcm_open.
- * @ingroup libtinyalsa-pcm
- */
-#define PCM_OUT 0x00000000
-
-/** Specifies that the PCM is an input.
- * May not be bitwise AND'd with @ref PCM_OUT.
- * Used in @ref pcm_open.
- * @ingroup libtinyalsa-pcm
- */
-#define PCM_IN 0x10000000
-
-/** Specifies that the PCM will use mmap read and write methods.
- * Used in @ref pcm_open.
- * @ingroup libtinyalsa-pcm
- */
-#define PCM_MMAP 0x00000001
-
-/** Specifies no interrupt requests.
- * May only be bitwise AND'd with @ref PCM_MMAP.
- * Used in @ref pcm_open.
- * @ingroup libtinyalsa-pcm
- */
-#define PCM_NOIRQ 0x00000002
-
-/** When set, calls to @ref pcm_write
- * for a playback stream will not attempt
- * to restart the stream in the case of an
- * underflow, but will return -EPIPE instead.
- * After the first -EPIPE error, the stream
- * is considered to be stopped, and a second
- * call to pcm_write will attempt to restart
- * the stream.
- * Used in @ref pcm_open.
- * @ingroup libtinyalsa-pcm
- */
-#define PCM_NORESTART 0x00000004
-
-/** Specifies monotonic timestamps.
- * Used in @ref pcm_open.
- * @ingroup libtinyalsa-pcm
- */
-#define PCM_MONOTONIC 0x00000008
-
-/** For inputs, this means the PCM is recording audio samples.
- * For outputs, this means the PCM is playing audio samples.
- * @ingroup libtinyalsa-pcm
- */
-#define	PCM_STATE_RUNNING	0x03
-
-/** For inputs, this means an overrun occured.
- * For outputs, this means an underrun occured.
- */
-#define	PCM_STATE_XRUN 0x04
-
-/** For outputs, this means audio samples are played.
- * A PCM is in a draining state when it is coming to a stop.
- */
-#define	PCM_STATE_DRAINING 0x05
-
-/** Means a PCM is suspended.
- * @ingroup libtinyalsa-pcm
- */
-#define	PCM_STATE_SUSPENDED 0x07
-
-/** Means a PCM has been disconnected.
- * @ingroup libtinyalsa-pcm
- */
-#define	PCM_STATE_DISCONNECTED 0x08
-
-#define SNDRV_CHMAP_POSITION_MASK	0xffff
-#define SNDRV_CHMAP_PHASE_INVERSE	(0x01 << 16)
-#define SNDRV_CHMAP_DRIVER_SPEC		(0x02 << 16)
-#define SNDRV_PCM_IOCTL_PVERSION	_IOR('A', 0x00, int)
-#define SNDRV_PCM_IOCTL_INFO		_IOR('A', 0x01, struct snd_pcm_info)
-#define SNDRV_PCM_IOCTL_TSTAMP		_IOW('A', 0x02, int)
-#define SNDRV_PCM_IOCTL_TTSTAMP		_IOW('A', 0x03, int)
-#define SNDRV_PCM_IOCTL_HW_REFINE	_IOWR('A', 0x10, struct snd_pcm_hw_params)
-#define SNDRV_PCM_IOCTL_HW_PARAMS	_IOWR('A', 0x11, struct snd_pcm_hw_params)
-#define SNDRV_PCM_IOCTL_HW_FREE		_IO('A', 0x12)
-#define SNDRV_PCM_IOCTL_SW_PARAMS	_IOWR('A', 0x13, struct snd_pcm_sw_params)
-#define SNDRV_PCM_IOCTL_STATUS		_IOR('A', 0x20, struct snd_pcm_status)
-#define SNDRV_PCM_IOCTL_DELAY		_IOR('A', 0x21, snd_pcm_sframes_t)
-#define SNDRV_PCM_IOCTL_HWSYNC		_IO('A', 0x22)
-#define SNDRV_PCM_IOCTL_SYNC_PTR	_IOWR('A', 0x23, struct snd_pcm_sync_ptr)
-#define SNDRV_PCM_IOCTL_CHANNEL_INFO	_IOR('A', 0x32, struct snd_pcm_channel_info)
-#define SNDRV_PCM_IOCTL_PREPARE		_IO('A', 0x40)
-#define SNDRV_PCM_IOCTL_RESET		_IO('A', 0x41)
-#define SNDRV_PCM_IOCTL_START		_IO('A', 0x42)
-#define SNDRV_PCM_IOCTL_DROP		_IO('A', 0x43)
-#define SNDRV_PCM_IOCTL_DRAIN		_IO('A', 0x44)
-#define SNDRV_PCM_IOCTL_PAUSE		_IOW('A', 0x45, int)
-#define SNDRV_PCM_IOCTL_REWIND		_IOW('A', 0x46, snd_pcm_uframes_t)
-#define SNDRV_PCM_IOCTL_RESUME		_IO('A', 0x47)
-#define SNDRV_PCM_IOCTL_XRUN		_IO('A', 0x48)
-#define SNDRV_PCM_IOCTL_FORWARD		_IOW('A', 0x49, snd_pcm_uframes_t)
-#define SNDRV_PCM_IOCTL_WRITEI_FRAMES	_IOW('A', 0x50, struct snd_xferi)
-#define SNDRV_PCM_IOCTL_READI_FRAMES	_IOR('A', 0x51, struct snd_xferi)
-#define SNDRV_PCM_IOCTL_WRITEN_FRAMES	_IOW('A', 0x52, struct snd_xfern)
-#define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)
-#define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)
-#define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)
-
-#define	SNDRV_PCM_ACCESS_MMAP_INTERLEAVED	(( tinyalsa_snd_pcm_access_t) 0) /* interleaved mmap */
-#define	SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED	(( tinyalsa_snd_pcm_access_t) 1) /* noninterleaved mmap */
-#define	SNDRV_PCM_ACCESS_MMAP_COMPLEX		(( tinyalsa_snd_pcm_access_t) 2) /* complex mmap */
-#define	SNDRV_PCM_ACCESS_RW_INTERLEAVED		(( tinyalsa_snd_pcm_access_t) 3) /* readi/writei */
-#define	SNDRV_PCM_ACCESS_RW_NONINTERLEAVED	(( tinyalsa_snd_pcm_access_t) 4) /* readn/writen */
-#define	SNDRV_PCM_ACCESS_LAST		SNDRV_PCM_ACCESS_RW_NONINTERLEAVED
-
-#define	SNDRV_PCM_SUBFORMAT_STD		(( tinyalsa_snd_pcm_subformat_t) 0)
-#define	SNDRV_PCM_SUBFORMAT_LAST	SNDRV_PCM_SUBFORMAT_STD
-
-#define	SNDRV_PCM_SUBFORMAT_STD		(( tinyalsa_snd_pcm_subformat_t) 0)
-#define	SNDRV_PCM_SUBFORMAT_LAST	SNDRV_PCM_SUBFORMAT_STD
-#define SNDRV_PCM_INFO_MMAP		0x00000001	/* hardware supports mmap */
-#define SNDRV_PCM_INFO_MMAP_VALID	0x00000002	/* period data are valid during transfer */
-#define SNDRV_PCM_INFO_DOUBLE		0x00000004	/* Double buffering needed for PCM start/stop */
-#define SNDRV_PCM_INFO_BATCH		0x00000010	/* double buffering */
-#define SNDRV_PCM_INFO_INTERLEAVED	0x00000100	/* channels are interleaved */
-#define SNDRV_PCM_INFO_NONINTERLEAVED	0x00000200	/* channels are not interleaved */
-#define SNDRV_PCM_INFO_COMPLEX		0x00000400	/* complex frame organization (mmap only) */
-#define SNDRV_PCM_INFO_BLOCK_TRANSFER	0x00010000	/* hardware transfer block of samples */
-#define SNDRV_PCM_INFO_OVERRANGE	0x00020000	/* hardware supports ADC (capture) overrange detection */
-#define SNDRV_PCM_INFO_RESUME		0x00040000	/* hardware supports stream resume after suspend */
-#define SNDRV_PCM_INFO_PAUSE		0x00080000	/* pause ioctl is supported */
-#define SNDRV_PCM_INFO_HALF_DUPLEX	0x00100000	/* only half duplex */
-#define SNDRV_PCM_INFO_JOINT_DUPLEX	0x00200000	/* playback and capture stream are somewhat correlated */
-#define SNDRV_PCM_INFO_SYNC_START	0x00400000	/* pcm support some kind of sync go */
-#define SNDRV_PCM_INFO_NO_PERIOD_WAKEUP	0x00800000	/* period wakeup can be disabled */
-#define SNDRV_PCM_INFO_HAS_WALL_CLOCK   0x01000000      /* has audio wall clock for audio/system time sync */
-#define SNDRV_PCM_INFO_FIFO_IN_FRAMES	0x80000000	/* internal kernel flag - FIFO size is in frames */
-#define	SNDRV_PCM_STATE_OPEN		(( tinyalsa_snd_pcm_state_t) 0) /* stream is open */
-#define	SNDRV_PCM_STATE_SETUP		(( tinyalsa_snd_pcm_state_t) 1) /* stream has a setup */
-#define	SNDRV_PCM_STATE_PREPARED	(( tinyalsa_snd_pcm_state_t) 2) /* stream is ready to start */
-#define	SNDRV_PCM_STATE_RUNNING		(( tinyalsa_snd_pcm_state_t) 3) /* stream is running */
-#define	SNDRV_PCM_STATE_XRUN		(( tinyalsa_snd_pcm_state_t) 4) /* stream reached an xrun */
-#define	SNDRV_PCM_STATE_DRAINING	(( tinyalsa_snd_pcm_state_t) 5) /* stream is draining */
-#define	SNDRV_PCM_STATE_PAUSED		(( tinyalsa_snd_pcm_state_t) 6) /* stream is paused */
-#define	SNDRV_PCM_STATE_SUSPENDED	(( tinyalsa_snd_pcm_state_t) 7) /* hardware is suspended */
-#define	SNDRV_PCM_STATE_DISCONNECTED	(( tinyalsa_snd_pcm_state_t) 8) /* hardware is disconnected */
-#define	SNDRV_PCM_STATE_LAST		SNDRV_PCM_STATE_DISCONNECTED
-
-#define	SNDRV_PCM_HW_PARAM_ACCESS	         0	/* Access type */
-#define	SNDRV_PCM_HW_PARAM_FORMAT	         1	/* Format */
-#define	SNDRV_PCM_HW_PARAM_SUBFORMAT	      2	/* Subformat */
-#define	SNDRV_PCM_HW_PARAM_FIRST_MASK	      SNDRV_PCM_HW_PARAM_ACCESS
-#define	SNDRV_PCM_HW_PARAM_LAST_MASK	      SNDRV_PCM_HW_PARAM_SUBFORMAT
-#define	SNDRV_PCM_HW_PARAM_SAMPLE_BITS	   8	/* Bits per sample */
-#define	SNDRV_PCM_HW_PARAM_FRAME_BITS	      9	/* Bits per frame */
-#define	SNDRV_PCM_HW_PARAM_CHANNELS	      10	/* Channels */
-#define	SNDRV_PCM_HW_PARAM_RATE		         11	/* Approx rate */
-#define	SNDRV_PCM_HW_PARAM_PERIOD_TIME	   12	/* Approx distance between interrupts in us */
-#define	SNDRV_PCM_HW_PARAM_PERIOD_SIZE	   13	/* Approx frames between interrupts */
-#define	SNDRV_PCM_HW_PARAM_PERIOD_BYTES	   14	/* Approx bytes between interrupts */
-#define	SNDRV_PCM_HW_PARAM_PERIODS	         15	/* Approx interrupts per buffer */
-#define	SNDRV_PCM_HW_PARAM_BUFFER_TIME	   16	/* Approx duration of buffer in us */
-#define	SNDRV_PCM_HW_PARAM_BUFFER_SIZE	   17	/* Size of buffer in frames */
-#define	SNDRV_PCM_HW_PARAM_BUFFER_BYTES	   18	/* Size of buffer in bytes */
-#define	SNDRV_PCM_HW_PARAM_TICK_TIME	      19	/* Approx tick duration in us */
-#define	SNDRV_PCM_HW_PARAM_FIRST_INTERVAL	SNDRV_PCM_HW_PARAM_SAMPLE_BITS
-#define	SNDRV_PCM_HW_PARAM_LAST_INTERVAL	   SNDRV_PCM_HW_PARAM_TICK_TIME
-#define SNDRV_PCM_HW_PARAMS_NORESAMPLE	      (1<<0)	/* avoid rate resampling */
-#define SNDRV_PCM_HW_PARAMS_EXPORT_BUFFER	   (1<<1)	/* export buffer */
-#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP	(1<<2)	/* disable period wakeups */
-
-#define	SNDRV_PCM_FORMAT_S8	(( tinyalsa_snd_pcm_format_t) 0)
-#define	SNDRV_PCM_FORMAT_U8	(( tinyalsa_snd_pcm_format_t) 1)
-#define	SNDRV_PCM_FORMAT_S16_LE	(( tinyalsa_snd_pcm_format_t) 2)
-#define	SNDRV_PCM_FORMAT_S16_BE	(( tinyalsa_snd_pcm_format_t) 3)
-#define	SNDRV_PCM_FORMAT_U16_LE	(( tinyalsa_snd_pcm_format_t) 4)
-#define	SNDRV_PCM_FORMAT_U16_BE	(( tinyalsa_snd_pcm_format_t) 5)
-#define	SNDRV_PCM_FORMAT_S24_LE	(( tinyalsa_snd_pcm_format_t) 6) /* low three bytes */
-#define	SNDRV_PCM_FORMAT_S24_BE	(( tinyalsa_snd_pcm_format_t) 7) /* low three bytes */
-#define	SNDRV_PCM_FORMAT_U24_LE	(( tinyalsa_snd_pcm_format_t) 8) /* low three bytes */
-#define	SNDRV_PCM_FORMAT_U24_BE	(( tinyalsa_snd_pcm_format_t) 9) /* low three bytes */
-#define	SNDRV_PCM_FORMAT_S32_LE	(( tinyalsa_snd_pcm_format_t) 10)
-#define	SNDRV_PCM_FORMAT_S32_BE	(( tinyalsa_snd_pcm_format_t) 11)
-#define	SNDRV_PCM_FORMAT_U32_LE	(( tinyalsa_snd_pcm_format_t) 12)
-#define	SNDRV_PCM_FORMAT_U32_BE	(( tinyalsa_snd_pcm_format_t) 13)
-#define	SNDRV_PCM_FORMAT_FLOAT_LE	(( tinyalsa_snd_pcm_format_t) 14) /* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */
-#define	SNDRV_PCM_FORMAT_FLOAT_BE	(( tinyalsa_snd_pcm_format_t) 15) /* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */
-#define	SNDRV_PCM_FORMAT_FLOAT64_LE	(( tinyalsa_snd_pcm_format_t) 16) /* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */
-#define	SNDRV_PCM_FORMAT_FLOAT64_BE	(( tinyalsa_snd_pcm_format_t) 17) /* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */
-#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE (( tinyalsa_snd_pcm_format_t) 18) /* IEC-958 subframe, Little Endian */
-#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE (( tinyalsa_snd_pcm_format_t) 19) /* IEC-958 subframe, Big Endian */
-#define	SNDRV_PCM_FORMAT_MU_LAW		(( tinyalsa_snd_pcm_format_t) 20)
-#define	SNDRV_PCM_FORMAT_A_LAW		(( tinyalsa_snd_pcm_format_t) 21)
-#define	SNDRV_PCM_FORMAT_IMA_ADPCM	(( tinyalsa_snd_pcm_format_t) 22)
-#define	SNDRV_PCM_FORMAT_MPEG		(( tinyalsa_snd_pcm_format_t) 23)
-#define	SNDRV_PCM_FORMAT_GSM		(( tinyalsa_snd_pcm_format_t) 24)
-#define	SNDRV_PCM_FORMAT_SPECIAL	(( tinyalsa_snd_pcm_format_t) 31)
-#define	SNDRV_PCM_FORMAT_S24_3LE	(( tinyalsa_snd_pcm_format_t) 32)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_S24_3BE	(( tinyalsa_snd_pcm_format_t) 33)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_U24_3LE	(( tinyalsa_snd_pcm_format_t) 34)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_U24_3BE	(( tinyalsa_snd_pcm_format_t) 35)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_S20_3LE	(( tinyalsa_snd_pcm_format_t) 36)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_S20_3BE	(( tinyalsa_snd_pcm_format_t) 37)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_U20_3LE	(( tinyalsa_snd_pcm_format_t) 38)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_U20_3BE	(( tinyalsa_snd_pcm_format_t) 39)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_S18_3LE	(( tinyalsa_snd_pcm_format_t) 40)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_S18_3BE	(( tinyalsa_snd_pcm_format_t) 41)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_U18_3LE	(( tinyalsa_snd_pcm_format_t) 42)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_U18_3BE	(( tinyalsa_snd_pcm_format_t) 43)	/* in three bytes */
-#define	SNDRV_PCM_FORMAT_G723_24	(( tinyalsa_snd_pcm_format_t) 44) /* 8 samples in 3 bytes */
-#define	SNDRV_PCM_FORMAT_G723_24_1B	(( tinyalsa_snd_pcm_format_t) 45) /* 1 sample in 1 byte */
-#define	SNDRV_PCM_FORMAT_G723_40	(( tinyalsa_snd_pcm_format_t) 46) /* 8 Samples in 5 bytes */
-#define	SNDRV_PCM_FORMAT_G723_40_1B	(( tinyalsa_snd_pcm_format_t) 47) /* 1 sample in 1 byte */
-#define	SNDRV_PCM_FORMAT_DSD_U8		(( tinyalsa_snd_pcm_format_t) 48) /* DSD, 1-byte samples DSD (x8) */
-#define	SNDRV_PCM_FORMAT_DSD_U16_LE	(( tinyalsa_snd_pcm_format_t) 49) /* DSD, 2-byte samples DSD (x16), little endian */
-#define	SNDRV_PCM_FORMAT_DSD_U32_LE	(( tinyalsa_snd_pcm_format_t) 50) /* DSD, 4-byte samples DSD (x32), little endian */
-#define	SNDRV_PCM_FORMAT_DSD_U16_BE	(( tinyalsa_snd_pcm_format_t) 51) /* DSD, 2-byte samples DSD (x16), big endian */
-#define	SNDRV_PCM_FORMAT_DSD_U32_BE	(( tinyalsa_snd_pcm_format_t) 52) /* DSD, 4-byte samples DSD (x32), big endian */
-#define	SNDRV_PCM_FORMAT_LAST		SNDRV_PCM_FORMAT_DSD_U32_BE
-
-#define SNDRV_MASK_MAX	               256
-
-#define SNDRV_PCM_SYNC_PTR_HWSYNC	   (1<<0)	/* execute hwsync */
-#define SNDRV_PCM_SYNC_PTR_APPL		   (1<<1)	/* get appl_ptr from driver (r/w op) */
-#define SNDRV_PCM_SYNC_PTR_AVAIL_MIN	(1<<2)	/* get avail_min from driver */
-
-#define SNDRV_PCM_MMAP_OFFSET_DATA     0x00000000
-#define SNDRV_PCM_MMAP_OFFSET_STATUS   0x80000000
-#define SNDRV_PCM_MMAP_OFFSET_CONTROL  0x81000000
-
-/** Audio sample format of a PCM.
- * The first letter specifiers whether the sample is signed or unsigned.
- * The letter 'S' means signed. The letter 'U' means unsigned.
- * The following number is the amount of bits that the sample occupies in memory.
- * Following the underscore, specifiers whether the sample is big endian or little endian.
- * The letters 'LE' mean little endian.
- * The letters 'BE' mean big endian.
- * This enumeration is used in the @ref pcm_config structure.
- * @ingroup libtinyalsa-pcm
- */
-enum pcm_format
-{
-   /** Signed, 8-bit */
-   PCM_FORMAT_S8 = 1,
-   /** Signed 16-bit, little endian */
-   PCM_FORMAT_S16_LE = 0,
-   /** Signed, 16-bit, big endian */
-   PCM_FORMAT_S16_BE = 2,
-   /** Signed, 24-bit (32-bit in memory), little endian */
-   PCM_FORMAT_S24_LE,
-   /** Signed, 24-bit (32-bit in memory), big endian */
-   PCM_FORMAT_S24_BE,
-   /** Signed, 24-bit, little endian */
-   PCM_FORMAT_S24_3LE,
-   /** Signed, 24-bit, big endian */
-   PCM_FORMAT_S24_3BE,
-   /** Signed, 32-bit, little endian */
-   PCM_FORMAT_S32_LE,
-   /** Signed, 32-bit, big endian */
-   PCM_FORMAT_S32_BE,
-   /** Max of the enumeration list, not an actual format. */
-   PCM_FORMAT_MAX
-};
-
-enum
-{
-	SNDRV_PCM_TSTAMP_NONE = 0,
-	SNDRV_PCM_TSTAMP_ENABLE,
-	SNDRV_PCM_TSTAMP_LAST = SNDRV_PCM_TSTAMP_ENABLE
-};
-
-/** Enumeration of a PCM's hardware parameters.
- * Each of these parameters is either a mask or an interval.
- * @ingroup libtinyalsa-pcm
- */
-enum pcm_param
-{
-   /** A mask that represents the type of read or write method available (e.g. interleaved, mmap). */
-   PCM_PARAM_ACCESS,
-   /** A mask that represents the @ref pcm_format available (e.g. @ref PCM_FORMAT_S32_LE) */
-   PCM_PARAM_FORMAT,
-   /** A mask that represents the subformat available */
-   PCM_PARAM_SUBFORMAT,
-   /** An interval representing the range of sample bits available (e.g. 8 to 32) */
-   PCM_PARAM_SAMPLE_BITS,
-   /** An interval representing the range of frame bits available (e.g. 8 to 64) */
-   PCM_PARAM_FRAME_BITS,
-   /** An interval representing the range of channels available (e.g. 1 to 2) */
-   PCM_PARAM_CHANNELS,
-   /** An interval representing the range of rates available (e.g. 44100 to 192000) */
-   PCM_PARAM_RATE,
-   PCM_PARAM_PERIOD_TIME,
-   /** The number of frames in a period */
-   PCM_PARAM_PERIOD_SIZE,
-   /** The number of bytes in a period */
-   PCM_PARAM_PERIOD_BYTES,
-   /** The number of periods for a PCM */
-   PCM_PARAM_PERIODS,
-   PCM_PARAM_BUFFER_TIME,
-   PCM_PARAM_BUFFER_SIZE,
-   PCM_PARAM_BUFFER_BYTES,
-   PCM_PARAM_TICK_TIME
-}; /* enum pcm_param */
-
-/* channel positions */
-enum
-{
-	SNDRV_CHMAP_UNKNOWN = 0,
-	SNDRV_CHMAP_NA,		/* N/A, silent */
-	SNDRV_CHMAP_MONO,	/* mono stream */
-	/* this follows the alsa-lib mixer channel value + 3 */
-	SNDRV_CHMAP_FL,		/* front left */
-	SNDRV_CHMAP_FR,		/* front right */
-	SNDRV_CHMAP_RL,		/* rear left */
-	SNDRV_CHMAP_RR,		/* rear right */
-	SNDRV_CHMAP_FC,		/* front center */
-	SNDRV_CHMAP_LFE,	/* LFE */
-	SNDRV_CHMAP_SL,		/* side left */
-	SNDRV_CHMAP_SR,		/* side right */
-	SNDRV_CHMAP_RC,		/* rear center */
-	/* new definitions */
-	SNDRV_CHMAP_FLC,	/* front left center */
-	SNDRV_CHMAP_FRC,	/* front right center */
-	SNDRV_CHMAP_RLC,	/* rear left center */
-	SNDRV_CHMAP_RRC,	/* rear right center */
-	SNDRV_CHMAP_FLW,	/* front left wide */
-	SNDRV_CHMAP_FRW,	/* front right wide */
-	SNDRV_CHMAP_FLH,	/* front left high */
-	SNDRV_CHMAP_FCH,	/* front center high */
-	SNDRV_CHMAP_FRH,	/* front right high */
-	SNDRV_CHMAP_TC,		/* top center */
-	SNDRV_CHMAP_TFL,	/* top front left */
-	SNDRV_CHMAP_TFR,	/* top front right */
-	SNDRV_CHMAP_TFC,	/* top front center */
-	SNDRV_CHMAP_TRL,	/* top rear left */
-	SNDRV_CHMAP_TRR,	/* top rear right */
-	SNDRV_CHMAP_TRC,	/* top rear center */
-	/* new definitions for UAC2 */
-	SNDRV_CHMAP_TFLC,	/* top front left center */
-	SNDRV_CHMAP_TFRC,	/* top front right center */
-	SNDRV_CHMAP_TSL,	/* top side left */
-	SNDRV_CHMAP_TSR,	/* top side right */
-	SNDRV_CHMAP_LLFE,	/* left LFE */
-	SNDRV_CHMAP_RLFE,	/* right LFE */
-	SNDRV_CHMAP_BC,		/* bottom center */
-	SNDRV_CHMAP_BLC,	/* bottom left center */
-	SNDRV_CHMAP_BRC,	/* bottom right center */
-	SNDRV_CHMAP_LAST = SNDRV_CHMAP_BRC
-};
-
-enum
-{
-   SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,	/* gettimeofday equivalent */
-   SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,	         /* posix_clock_monotonic equivalent */
-   SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,      /* monotonic_raw (no NTP) */
-   SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW
-};
-
-typedef unsigned long snd_pcm_uframes_t;
-typedef signed long snd_pcm_sframes_t;
-typedef int snd_pcm_hw_param_t;
-typedef int __bitwise tinyalsa_snd_pcm_access_t;
-typedef int __bitwise tinyalsa_snd_pcm_subformat_t;
-typedef int __bitwise tinyalsa_snd_pcm_state_t;
-typedef int __bitwise tinyalsa_snd_pcm_format_t;
-
-/** A bit mask of 256 bits (32 bytes) that describes some hardware parameters of a PCM */
-struct pcm_mask
-{
-    /** bits of the bit mask */
-    unsigned int bits[32 / sizeof(unsigned int)];
-};
-
-union snd_pcm_sync_id
-{
-	unsigned char id[16];
-	unsigned short id16[8];
-	unsigned int id32[4];
-};
-
-struct snd_pcm_mmap_status
-{
-	tinyalsa_snd_pcm_state_t state;		/* RO: state - SNDRV_PCM_STATE_XXXX */
-	int pad1;			/* Needed for 64 bit alignment */
-	snd_pcm_uframes_t hw_ptr;	/* RO: hw ptr (0...boundary-1) */
-	struct timespec tstamp;		/* Timestamp */
-	tinyalsa_snd_pcm_state_t suspended_state; /* RO: suspended stream state */
-	struct timespec audio_tstamp;	/* from sample counter or wall clock */
-};
-
-struct snd_pcm_info
-{
-	unsigned int device;		/* RO/WR (control): device number */
-	unsigned int subdevice;		/* RO/WR (control): subdevice number */
-	int stream;			/* RO/WR (control): stream direction */
-	int card;			/* R: card number */
-	unsigned char id[64];		/* ID (user selectable) */
-	unsigned char name[80];		/* name of this device */
-	unsigned char subname[32];	/* subdevice name */
-	int dev_class;			/* SNDRV_PCM_CLASS_* */
-	int dev_subclass;		/* SNDRV_PCM_SUBCLASS_* */
-	unsigned int subdevices_count;
-	unsigned int subdevices_avail;
-	union snd_pcm_sync_id sync;	/* hardware synchronization ID */
-	unsigned char reserved[64];	/* reserved for future... */
-};
-
-struct snd_interval
-{
-   unsigned int min, max;
-   unsigned int openmin:1,
-                openmax:1,
-                integer:1,
-                empty:1;
-};
-
-struct snd_mask
-{
-	__u32 bits[(SNDRV_MASK_MAX+31)/32];
-};
-
-struct snd_pcm_sw_params
-{
-	int tstamp_mode;			/* timestamp mode */
-	unsigned int period_step;
-	unsigned int sleep_min;			/* min ticks to sleep */
-	snd_pcm_uframes_t avail_min;		/* min avail frames for wakeup */
-	snd_pcm_uframes_t xfer_align;		/* obsolete: xfer size need to be a multiple */
-	snd_pcm_uframes_t start_threshold;	/* min hw_avail frames for automatic start */
-	snd_pcm_uframes_t stop_threshold;	/* min avail frames for automatic stop */
-	snd_pcm_uframes_t silence_threshold;	/* min distance from noise for silence filling */
-	snd_pcm_uframes_t silence_size;		/* silence block size */
-	snd_pcm_uframes_t boundary;		/* pointers wrap point */
-	unsigned int proto;			/* protocol version */
-	unsigned int tstamp_type;		/* timestamp type (req. proto >= 2.0.12) */
-	unsigned char reserved[56];		/* reserved for future */
-};
-
-struct snd_pcm_hw_params
-{
-   unsigned int flags;
-   struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK -
-      SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
-   struct snd_mask mres[5];	/* reserved masks */
-   struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
-      SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
-   struct snd_interval ires[9];	/* reserved intervals */
-   unsigned int rmask;		/* W: requested masks */
-   unsigned int cmask;		/* R: changed masks */
-   unsigned int info;		/* R: Info flags for returned setup */
-   unsigned int msbits;		/* R: used most significant bits */
-   unsigned int rate_num;		/* R: rate numerator */
-   unsigned int rate_den;		/* R: rate denominator */
-   snd_pcm_uframes_t fifo_size;	/* R: chip FIFO size in frames */
-   unsigned char reserved[64];	/* reserved for future */
-};
-
-/** Encapsulates the hardware and software parameters of a PCM.
- * @ingroup libtinyalsa-pcm
- */
-struct pcm_config
-{
-   /** The number of channels in a frame */
-   unsigned int channels;
-   /** The number of frames per second */
-   unsigned int rate;
-   /** The number of frames in a period */
-   unsigned int period_size;
-   /** The number of periods in a PCM */
-   unsigned int period_count;
-   /** The sample format of a PCM */
-   enum pcm_format format;
-   /* Values to use for the ALSA start, stop and silence thresholds.  Setting
-    * any one of these values to 0 will cause the default tinyalsa values to be
-    * used instead.  Tinyalsa defaults are as follows.
-    *
-    * start_threshold   : period_count * period_size
-    * stop_threshold    : period_count * period_size
-    * silence_threshold : 0
-    */
-   /** The minimum number of frames required to start the PCM */
-   unsigned int start_threshold;
-   /** The minimum number of frames required to stop the PCM */
-   unsigned int stop_threshold;
-   /** The minimum number of frames to silence the PCM */
-   unsigned int silence_threshold;
-};
-
-struct snd_pcm_mmap_control
-{
-	snd_pcm_uframes_t appl_ptr;	/* RW: appl ptr (0...boundary-1) */
-	snd_pcm_uframes_t avail_min;	/* RW: min available frames for wakeup */
-};
-
-struct snd_pcm_sync_ptr
-{
-   unsigned int flags;
-   union
-   {
-      struct snd_pcm_mmap_status status;
-      unsigned char reserved[64];
-   } s;
-   union
-   {
-      struct snd_pcm_mmap_control control;
-      unsigned char reserved[64];
-   } c;
-};
-
-struct snd_xferi
-{
-   snd_pcm_sframes_t result;
-   void  *buf;
-   snd_pcm_uframes_t frames;
-};
-
-struct snd_xfern
-{
-   snd_pcm_sframes_t result;
-   void  *  *bufs;
-   snd_pcm_uframes_t frames;
-};
-
-struct snd_pcm_status
-{
-   tinyalsa_snd_pcm_state_t state;		/* stream state */
-   struct timespec trigger_tstamp;	/* time when stream was started/stopped/paused */
-   struct timespec tstamp;		/* reference timestamp */
-   snd_pcm_uframes_t appl_ptr;	/* appl ptr */
-   snd_pcm_uframes_t hw_ptr;	/* hw ptr */
-   snd_pcm_sframes_t delay;	/* current delay in frames */
-   snd_pcm_uframes_t avail;	/* number of frames available */
-   snd_pcm_uframes_t avail_max;	/* max frames available on hw since last status */
-   snd_pcm_uframes_t overrange;	/* count of ADC (capture) overrange detections from last status */
-   tinyalsa_snd_pcm_state_t suspended_state; /* suspended stream state */
-   __u32 reserved_alignment;	/* must be filled with zero */
-   struct timespec audio_tstamp;	/* from sample counter or wall clock */
-   unsigned char reserved[56-sizeof(struct timespec)]; /* must be filled with zero */
-};
-
-struct pcm_params;
-
-#define TINYALSA_CHANNELS_MAX 32U
-#define TINYALSA_CHANNELS_MIN 1U
-#define TINYALSA_FRAMES_MAX (ULONG_MAX / (TINYALSA_CHANNELS_MAX * 4))
-
-#define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
-#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP (1<<2)
-
-static INLINE int param_is_mask(int p)
-{
-   return (p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
-      (p <= SNDRV_PCM_HW_PARAM_LAST_MASK);
-}
-
-static INLINE int param_is_interval(int p)
-{
-   return (p >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL) &&
-      (p <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL);
-}
-
-static INLINE const struct snd_interval *param_get_interval(const struct snd_pcm_hw_params *p, int n)
-{
-   return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
-}
-
-static INLINE struct snd_interval *param_to_interval(struct snd_pcm_hw_params *p, int n)
-{
-    return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
-}
-
-static INLINE struct snd_mask *param_to_mask(struct snd_pcm_hw_params *p, int n)
-{
-    return &(p->masks[n - SNDRV_PCM_HW_PARAM_FIRST_MASK]);
-}
-
-static void param_set_mask(struct snd_pcm_hw_params *p, int n, unsigned int bit)
-{
-    if (bit >= SNDRV_MASK_MAX)
-        return;
-    if (param_is_mask(n))
-    {
-        struct snd_mask *m = param_to_mask(p, n);
-        m->bits[0] = 0;
-        m->bits[1] = 0;
-        m->bits[bit >> 5] |= (1 << (bit & 31));
-    }
-}
-
-static void param_set_min(struct snd_pcm_hw_params *p, int n, unsigned int val)
-{
-    if (param_is_interval(n))
-    {
-        struct snd_interval *i = param_to_interval(p, n);
-        i->min = val;
-    }
-}
-
-static void param_set_int(struct snd_pcm_hw_params *p, int n, unsigned int val)
-{
-    if (param_is_interval(n))
-    {
-        struct snd_interval *i = param_to_interval(p, n);
-        i->min = val;
-        i->max = val;
-        i->integer = 1;
-    }
-}
-
-static unsigned int param_get_int(struct snd_pcm_hw_params *p, int n)
-{
-    if (param_is_interval(n))
-    {
-        struct snd_interval *i = param_to_interval(p, n);
-        if (i->integer)
-            return i->max;
-    }
-    return 0;
-}
-
-static void param_init(struct snd_pcm_hw_params *p)
-{
-   int n;
-
-   memset(p, 0, sizeof(*p));
-   for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
-         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++)
-   {
-      struct snd_mask *m = param_to_mask(p, n);
-      m->bits[0] = ~0;
-      m->bits[1] = ~0;
-   }
-   for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
-         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++)
-   {
-      struct snd_interval *i = param_to_interval(p, n);
-      i->min = 0;
-      i->max = ~0;
-   }
-   p->rmask = ~0U;
-   p->cmask = 0;
-   p->info = ~0U;
-}
-
-static unsigned int pcm_format_to_alsa(enum pcm_format format)
-{
-   switch (format)
-   {
-      case PCM_FORMAT_S8:
-         return SNDRV_PCM_FORMAT_S8;
-
-      default:
-      case PCM_FORMAT_S16_LE:
-         return SNDRV_PCM_FORMAT_S16_LE;
-      case PCM_FORMAT_S16_BE:
-         return SNDRV_PCM_FORMAT_S16_BE;
-
-      case PCM_FORMAT_S24_LE:
-         return SNDRV_PCM_FORMAT_S24_LE;
-      case PCM_FORMAT_S24_BE:
-         return SNDRV_PCM_FORMAT_S24_BE;
-
-      case PCM_FORMAT_S24_3LE:
-         return SNDRV_PCM_FORMAT_S24_3LE;
-      case PCM_FORMAT_S24_3BE:
-         return SNDRV_PCM_FORMAT_S24_3BE;
-
-      case PCM_FORMAT_S32_LE:
-         return SNDRV_PCM_FORMAT_S32_LE;
-      case PCM_FORMAT_S32_BE:
-         return SNDRV_PCM_FORMAT_S32_BE;
-   }
-}
-
-#define PCM_ERROR_MAX 128
-
-/** A PCM handle.
- * @ingroup libtinyalsa-pcm
- */
-struct pcm
-{
-   /** The PCM's file descriptor */
-   int fd;
-   /** Flags that were passed to @ref pcm_open */
-   unsigned int flags;
-   /** Whether the PCM is running or not */
-   unsigned int running:1;
-   /** Whether or not the PCM has been prepared */
-   unsigned int prepared:1;
-   /** The number of underruns that have occured */
-   int underruns;
-   /** Size of the buffer */
-   unsigned int buffer_size;
-   /** The boundary for ring buffer pointers */
-   unsigned int boundary;
-   /** Description of the last error that occured */
-   char error[PCM_ERROR_MAX];
-   /** Configuration that was passed to @ref pcm_open */
-   struct pcm_config config;
-   struct snd_pcm_mmap_status *mmap_status;
-   struct snd_pcm_mmap_control *mmap_control;
-   struct snd_pcm_sync_ptr *sync_ptr;
-   void *mmap_buffer;
-   unsigned int noirq_frames_per_msec;
-   /** The delay of the PCM, in terms of frames */
-   long pcm_delay;
-   /** The subdevice corresponding to the PCM */
-   unsigned int subdevice;
-};
-
-/** Gets the buffer size of the PCM.
- * @param pcm A PCM handle.
- * @return The buffer size of the PCM.
- * @ingroup libtinyalsa-pcm
- */
-static unsigned int pcm_get_buffer_size(const struct pcm *pcm)
-{
-   return pcm->buffer_size;
-}
-
-#if 0
-/* Unused for now */
-
-/** Gets the channel count of the PCM.
- * @param pcm A PCM handle.
- * @return The channel count of the PCM.
- * @ingroup libtinyalsa-pcm
- */
-static unsigned int pcm_get_channels(const struct pcm *pcm)
-{
-   return pcm->config.channels;
-}
-
-/** Gets the PCM configuration.
- * @param pcm A PCM handle.
- * @return The PCM configuration.
- *  This function only returns NULL if
- *  @p pcm is NULL.
- * @ingroup libtinyalsa-pcm
- * */
-static const struct pcm_config * pcm_get_config(const struct pcm *pcm)
-{
-   if (!pcm)
-      return NULL;
-   return &pcm->config;
-}
-
-/** Gets the rate of the PCM.
- * The rate is given in frames per second.
- * @param pcm A PCM handle.
- * @return The rate of the PCM.
- * @ingroup libtinyalsa-pcm
- */
-static unsigned int pcm_get_rate(const struct pcm *pcm)
-{
-   return pcm->config.rate;
-}
-
-/** Gets the format of the PCM.
- * @param pcm A PCM handle.
- * @return The format of the PCM.
- * @ingroup libtinyalsa-pcm
- */
-static enum pcm_format pcm_get_format(const struct pcm *pcm)
-{
-   return pcm->config.format;
-}
-
-/** Gets the file descriptor of the PCM.
- * Useful for extending functionality of the PCM when needed.
- * @param pcm A PCM handle.
- * @return The file descriptor of the PCM.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_get_file_descriptor(const struct pcm *pcm)
-{
-   return pcm->fd;
-}
-
-/** Gets the error message for the last error that occured.
- * If no error occured and this function is called, the results are undefined.
- * @param pcm A PCM handle.
- * @return The error message of the last error that occured.
- * @ingroup libtinyalsa-pcm
- */
-static const char* pcm_get_error(const struct pcm *pcm)
-{
-   return pcm->error;
-}
-
-/** Gets the subdevice on which the pcm has been opened.
- * @param pcm A PCM handle.
- * @return The subdevice on which the pcm has been opened */
-static unsigned int pcm_get_subdevice(const struct pcm *pcm)
-{
-    return pcm->subdevice;
-}
-
-/** Determines how many frames of a PCM can fit into a number of bytes.
- * @param pcm A PCM handle.
- * @param bytes The number of bytes.
- * @return The number of frames that may fit into @p bytes
- * @ingroup libtinyalsa-pcm
- */
-static unsigned int pcm_bytes_to_frames(const struct pcm *pcm, unsigned int bytes)
-{
-    return bytes / (pcm->config.channels *
-        (pcm_format_to_bits(pcm->config.format) >> 3));
-}
-#endif
-
-/** Determines the number of bits occupied by a @ref pcm_format.
- * @param format A PCM format.
- * @return The number of bits associated with @p format
- * @ingroup libtinyalsa-pcm
- */
-unsigned int pcm_format_to_bits(enum pcm_format format)
-{
-   switch (format)
-   {
-      case PCM_FORMAT_S32_LE:
-      case PCM_FORMAT_S32_BE:
-      case PCM_FORMAT_S24_LE:
-      case PCM_FORMAT_S24_BE:
-         return 32;
-      case PCM_FORMAT_S24_3LE:
-      case PCM_FORMAT_S24_3BE:
-         return 24;
-      default:
-      case PCM_FORMAT_S16_LE:
-      case PCM_FORMAT_S16_BE:
-         return 16;
-      case PCM_FORMAT_S8:
-         return 8;
-   }
-}
-
-/** Determines how many bytes are occupied by a number of frames of a PCM.
- * @param pcm A PCM handle.
- * @param frames The number of frames of a PCM.
- * @return The bytes occupied by @p frames.
- * @ingroup libtinyalsa-pcm
- */
-static unsigned int pcm_frames_to_bytes(const struct pcm *pcm, unsigned int frames)
-{
-   return frames * pcm->config.channels *
-      (pcm_format_to_bits(pcm->config.format) >> 3);
-}
-
-/** Sets the PCM configuration.
- * @param pcm A PCM handle.
- * @param config The configuration to use for the
- *  PCM. This parameter may be NULL, in which case
- *  the default configuration is used.
- * @returns Zero on success, a negative errno value
- *  on failure.
- * @ingroup libtinyalsa-pcm
- * */
-static int pcm_set_config(struct pcm *pcm, const struct pcm_config *config)
-{
-    struct snd_pcm_sw_params sparams;
-    struct snd_pcm_hw_params params;
-
-    if (!pcm)
-        return -EFAULT;
-
-    if (config)
-        pcm->config = *config;
-    else
-    {
-        config = &pcm->config;
-        pcm->config.channels = 2;
-        pcm->config.rate = 48000;
-        pcm->config.period_size = 1024;
-        pcm->config.period_count = 4;
-        pcm->config.format = PCM_FORMAT_S16_LE;
-        pcm->config.start_threshold = config->period_count * config->period_size;
-        pcm->config.stop_threshold = config->period_count * config->period_size;
-        pcm->config.silence_threshold = 0;
-    }
-
-    param_init(&params);
-    param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
-                   pcm_format_to_alsa(config->format));
-    param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
-                   SNDRV_PCM_SUBFORMAT_STD);
-    param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, config->period_size);
-    param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
-                  pcm_format_to_bits(config->format));
-    param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
-                  pcm_format_to_bits(config->format) * config->channels);
-    param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
-                  config->channels);
-    param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
-    param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
-
-    if (pcm->flags & PCM_NOIRQ)
-    {
-        if (!(pcm->flags & PCM_MMAP))
-        {
-            RARCH_ERR("[TINYALSA]: noirq only currently supported with mmap().");
-            return -EINVAL;
-        }
-
-        params.flags |= SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP;
-        pcm->noirq_frames_per_msec = config->rate / 1000;
-    }
-
-    if (pcm->flags & PCM_MMAP)
-        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
-                   SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
-    else
-        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
-                   SNDRV_PCM_ACCESS_RW_INTERLEAVED);
-
-    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params))
-    {
-        RARCH_ERR("[TINYALSA]: cannot set HW params.");
-        return -errno;
-    }
-
-    /* get our refined hw_params */
-    pcm->config.period_size = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
-    pcm->config.period_count = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIODS);
-    pcm->buffer_size = config->period_count * config->period_size;
-
-    if (pcm->flags & PCM_MMAP)
-    {
-        pcm->mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm->buffer_size),
-                                PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm->fd, 0);
-        if (pcm->mmap_buffer == MAP_FAILED)
-        {
-            RARCH_ERR("[TINYALSA]: failed to mmap buffer %d bytes\n",
-                 pcm_frames_to_bytes(pcm, pcm->buffer_size));
-            return -errno;
-        }
-    }
-
-    memset(&sparams, 0, sizeof(sparams));
-    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_ENABLE;
-    sparams.period_step = 1;
-    sparams.avail_min   = 1;
-
-    if (!config->start_threshold)
-    {
-        if (pcm->flags & PCM_IN)
-            pcm->config.start_threshold = sparams.start_threshold = 1;
-        else
-            pcm->config.start_threshold = sparams.start_threshold =
-                config->period_count * config->period_size / 2;
-    } else
-        sparams.start_threshold = config->start_threshold;
-
-    /* pick a high stop threshold - todo: does this need further tuning */
-    if (!config->stop_threshold)
-    {
-        if (pcm->flags & PCM_IN)
-            pcm->config.stop_threshold = sparams.stop_threshold =
-                config->period_count * config->period_size * 10;
-        else
-            pcm->config.stop_threshold = sparams.stop_threshold =
-                config->period_count * config->period_size;
-    }
-    else
-        sparams.stop_threshold = config->stop_threshold;
-
-    sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
-    sparams.silence_size = 0;
-    sparams.silence_threshold = config->silence_threshold;
-    pcm->boundary = sparams.boundary = pcm->buffer_size;
-
-    while (pcm->boundary * 2 <= INT_MAX - pcm->buffer_size)
-        pcm->boundary *= 2;
-
-    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams))
-    {
-        RARCH_ERR("[TINYALSA]: Cannot set HW params.\n");
-        return -errno;
-    }
-
-    return 0;
-}
-
-static int pcm_sync_ptr(struct pcm *pcm, int flags)
-{
-   if (pcm->sync_ptr)
-   {
-      pcm->sync_ptr->flags = flags;
-      if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SYNC_PTR, pcm->sync_ptr) >= 0)
-         return 0;
-   }
-   return -1;
-}
-
-static int pcm_hw_mmap_status(struct pcm *pcm)
-{
-   int page_size;
-   if (pcm->sync_ptr)
-      return 0;
-
-   page_size = sysconf(_SC_PAGE_SIZE);
-
-   pcm->mmap_status = (struct snd_pcm_mmap_status*)
-      mmap(NULL, page_size, PROT_READ, MAP_FILE | MAP_SHARED,
-            pcm->fd, SNDRV_PCM_MMAP_OFFSET_STATUS);
-   if (pcm->mmap_status == MAP_FAILED)
-      pcm->mmap_status = NULL;
-   if (!pcm->mmap_status)
-      goto mmap_error;
-
-   pcm->mmap_control = (struct snd_pcm_mmap_control*)
-      mmap(NULL, (size_t)page_size, PROT_READ | PROT_WRITE,
-            MAP_FILE | MAP_SHARED, pcm->fd, SNDRV_PCM_MMAP_OFFSET_CONTROL);
-   if (pcm->mmap_control == MAP_FAILED)
-      pcm->mmap_control = NULL;
-   if (!pcm->mmap_control)
-   {
-      munmap(pcm->mmap_status, page_size);
-      pcm->mmap_status = NULL;
-      goto mmap_error;
-   }
-   pcm->mmap_control->avail_min = 1;
-
-   return 0;
-
-mmap_error:
-
-   pcm->sync_ptr = (struct snd_pcm_sync_ptr*)
-      calloc(1, sizeof(*pcm->sync_ptr));
-   if (!pcm->sync_ptr)
-      return -ENOMEM;
-   pcm->mmap_status = &pcm->sync_ptr->s.status;
-   pcm->mmap_control = &pcm->sync_ptr->c.control;
-   pcm->mmap_control->avail_min = 1;
-   pcm_sync_ptr(pcm, 0);
-
-   return 0;
-}
-
-static void pcm_hw_munmap_status(struct pcm *pcm)
-{
-    if (pcm->sync_ptr)
-    {
-        free(pcm->sync_ptr);
-        pcm->sync_ptr = NULL;
-    }
-    else
-    {
-        int page_size = sysconf(_SC_PAGE_SIZE);
-        if (pcm->mmap_status)
-            munmap(pcm->mmap_status, page_size);
-        if (pcm->mmap_control)
-            munmap(pcm->mmap_control, page_size);
-    }
-    pcm->mmap_status = NULL;
-    pcm->mmap_control = NULL;
-}
-
-#if 0
-/* Unused for now */
-
-static int pcm_areas_copy(struct pcm *pcm, unsigned int pcm_offset,
-                          char *buf, unsigned int src_offset,
-                          unsigned int frames)
-{
-    int size_bytes = pcm_frames_to_bytes(pcm, frames);
-    int pcm_offset_bytes = pcm_frames_to_bytes(pcm, pcm_offset);
-    int src_offset_bytes = pcm_frames_to_bytes(pcm, src_offset);
-
-    /* interleaved only atm */
-    if (pcm->flags & PCM_IN)
-        memcpy(buf + src_offset_bytes,
-               (char*)pcm->mmap_buffer + pcm_offset_bytes,
-               size_bytes);
-    else
-        memcpy((char*)pcm->mmap_buffer + pcm_offset_bytes,
-               buf + src_offset_bytes,
-               size_bytes);
-    return 0;
-}
-#endif
-
-static INLINE int pcm_mmap_capture_avail(struct pcm *pcm)
-{
-    int avail = pcm->mmap_status->hw_ptr - pcm->mmap_control->appl_ptr;
-    if (avail < 0)
-        avail += pcm->boundary;
-    return avail;
-}
-
-static INLINE int pcm_mmap_playback_avail(struct pcm *pcm)
-{
-    int avail = pcm->mmap_status->hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
-
-    if (avail < 0)
-        avail += pcm->boundary;
-    else if (avail >= (int)pcm->boundary)
-        avail -= pcm->boundary;
-
-    return avail;
-}
-
-static INLINE int pcm_mmap_avail(struct pcm *pcm)
-{
-    pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_HWSYNC);
-    if (pcm->flags & PCM_IN)
-        return pcm_mmap_capture_avail(pcm);
-    return pcm_mmap_playback_avail(pcm);
-}
-
-#if 0
-/* Unused for now */
-
-static int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
-      unsigned int *frames)
-{
-   unsigned int continuous, copy_frames, avail;
-
-   /* return the mmap buffer */
-   *areas = pcm->mmap_buffer;
-
-   /* and the application offset in frames */
-   *offset = pcm->mmap_control->appl_ptr % pcm->buffer_size;
-
-   avail = pcm_mmap_avail(pcm);
-   if (avail > pcm->buffer_size)
-      avail = pcm->buffer_size;
-   continuous = pcm->buffer_size - *offset;
-
-   /* we can only copy frames if the are availabale and continuos */
-   copy_frames = *frames;
-   if (copy_frames > avail)
-      copy_frames = avail;
-   if (copy_frames > continuous)
-      copy_frames = continuous;
-   *frames = copy_frames;
-
-   return 0;
-}
-
-static int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames)
-{
-   int ret;
-
-   /* not used */
-   (void) offset;
-
-   /* update the application pointer in userspace and kernel */
-   pcm_mmap_appl_forward(pcm, frames);
-   ret = pcm_sync_ptr(pcm, 0);
-   if (ret != 0)
-      return ret;
-
-   return frames;
-}
-
-static void pcm_mmap_appl_forward(struct pcm *pcm, int frames)
-{
-    unsigned int appl_ptr = pcm->mmap_control->appl_ptr;
-    appl_ptr += frames;
-
-    /* check for boundary wrap */
-    if (appl_ptr > pcm->boundary)
-         appl_ptr -= pcm->boundary;
-    pcm->mmap_control->appl_ptr = appl_ptr;
-}
-
-/** Returns available frames in pcm buffer and corresponding time stamp.
- * The clock is CLOCK_MONOTONIC if flag @ref PCM_MONOTONIC was specified in @ref pcm_open,
- * otherwise the clock is CLOCK_REALTIME.
- * For an input stream, frames available are frames ready for the application to read.
- * For an output stream, frames available are the number of empty frames available for the application to write.
- * Only available for PCMs opened with the @ref PCM_MMAP flag.
- * @param pcm A PCM handle.
- * @param avail The number of available frames
- * @param tstamp The timestamp
- * @return On success, zero is returned; on failure, negative one.
- */
-static int pcm_get_htimestamp(struct pcm *pcm, unsigned int *avail,
-      struct timespec *tstamp)
-{
-   int frames;
-   int rc;
-   snd_pcm_uframes_t hw_ptr;
-
-   if (!pcm_is_ready(pcm))
-      return -1;
-
-   rc = pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_APPL|SNDRV_PCM_SYNC_PTR_HWSYNC);
-   if (rc < 0)
-      return -1;
-
-   if ((pcm->mmap_status->state != PCM_STATE_RUNNING) &&
-         (pcm->mmap_status->state != PCM_STATE_DRAINING))
-      return -1;
-
-   *tstamp = pcm->mmap_status->tstamp;
-   if (tstamp->tv_sec == 0 && tstamp->tv_nsec == 0)
-      return -1;
-
-   hw_ptr = pcm->mmap_status->hw_ptr;
-   if (pcm->flags & PCM_IN)
-      frames = hw_ptr - pcm->mmap_control->appl_ptr;
-   else
-      frames = hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
-
-   if (frames < 0)
-      return -1;
-
-   *avail = (unsigned int)frames;
-
-   return 0;
-}
-#endif
-
-/** Checks if a PCM file has been opened without error.
- * @param pcm A PCM handle.
- *  May be NULL.
- * @return If a PCM's file descriptor is not valid or the pointer is NULL, it returns zero.
- *  Otherwise, the function returns one.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_is_ready(const struct pcm *pcm)
-{
-   if (pcm)
-      return pcm->fd >= 0;
-   return 0;
-}
-
-/** Prepares a PCM, if it has not been prepared already.
- * @param pcm A PCM handle.
- * @return On success, zero; on failure, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_prepare(struct pcm *pcm)
-{
-   if (pcm->prepared)
-      return 0;
-
-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE) < 0)
-   {
-      RARCH_ERR("[TINYALSA]: Cannot prepare channel.\n");
-      return -1;
-   }
-
-   pcm->prepared = 1;
-   return 0;
-}
-
-/** Writes audio samples to PCM.
- * If the PCM has not been started, it is started in this function.
- * This function is only valid for PCMs opened with the @ref PCM_OUT flag.
- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
- * @param pcm A PCM handle.
- * @param data The audio sample array
- * @param frame_count The number of frames occupied by the sample array.
- *  This value should not be greater than @ref TINYALSA_FRAMES_MAX
- *  or INT_MAX.
- * @return On success, this function returns the number of frames written; otherwise, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_writei(struct pcm *pcm, const void *data, unsigned int frame_count)
-{
-   struct snd_xferi x;
-
-   if (pcm->flags & PCM_IN)
-      return -EINVAL;
-#if UINT_MAX > TINYALSA_FRAMES_MAX
-   if (frame_count > TINYALSA_FRAMES_MAX)
-      return -EINVAL;
-#endif
-   if (frame_count > INT_MAX)
-      return -EINVAL;
-
-   x.buf    = (void*)data;
-   x.frames = frame_count;
-   x.result = 0;
-
-restart:
-   if (!pcm->running)
-   {
-      int prepare_error = pcm_prepare(pcm);
-      if (prepare_error)
-         return prepare_error;
-      if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
-      {
-         RARCH_ERR("[TINYALSA]: Cannot write initial data.\n");
-         return -1;
-      }
-      pcm->running = 1;
-      return 0;
-   }
-
-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
-   {
-      pcm->prepared = 0;
-      pcm->running = 0;
-      if (errno == EPIPE)
-      {
-         /* we failed to make our window -- try to restart if we are
-          * allowed to do so.  Otherwise, simply allow the EPIPE error to
-          * propagate up to the app level */
-         pcm->underruns++;
-         if (pcm->flags & PCM_NORESTART)
-            return -EPIPE;
-         goto restart;
-      }
-#if 0
-      /* This tends to spam a lot */
-      RARCH_ERR("[TINYALSA]: Cannot write stream data.\n");
-#endif
-      return -1;
-   }
-
-   return x.result;
-}
-
-#if 0
-/* Unused for now */
-/** Starts a PCM.
- * If the PCM has not been prepared,
- * it is prepared in this function.
- * @param pcm A PCM handle.
- * @return On success, zero; on failure, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_start(struct pcm *pcm)
-{
-   int prepare_error = pcm_prepare(pcm);
-   if (prepare_error)
-      return prepare_error;
-
-   if (pcm->flags & PCM_MMAP)
-      pcm_sync_ptr(pcm, 0);
-
-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START) < 0)
-   {
-      RARCH_ERR("[TINYALSA]: Cannot start channel.\n");
-      return -1;
-   }
-
-   pcm->running = 1;
-   return 0;
-}
-
-/** Reads audio samples from PCM.
- * If the PCM has not been started, it is started in this function.
- * This function is only valid for PCMs opened with the @ref PCM_IN flag.
- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
- * @param pcm A PCM handle.
- * @param data The audio sample array
- * @param frame_count The number of frames occupied by the sample array.
- *  This value should not be greater than @ref TINYALSA_FRAMES_MAX
- *  or INT_MAX.
- * @return On success, this function returns the number of frames written; otherwise, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_readi(struct pcm *pcm, void *data, unsigned int frame_count)
-{
-   struct snd_xferi x;
-
-   if (!(pcm->flags & PCM_IN))
-      return -EINVAL;
-#if UINT_MAX > TINYALSA_FRAMES_MAX
-   if (frame_count > TINYALSA_FRAMES_MAX)
-      return -EINVAL;
-#endif
-   if (frame_count > INT_MAX)
-      return -EINVAL;
-
-   x.buf    = data;
-   x.frames = frame_count;
-   x.result = 0;
-   for (;;)
-   {
-      if ((!pcm->running) && (pcm_start(pcm) < 0))
-         return -errno;
-      else if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_READI_FRAMES, &x))
-      {
-         pcm->prepared = 0;
-         pcm->running  = 0;
-         if (errno == EPIPE)
-         {
-            /* we failed to make our window -- try to restart */
-            pcm->underruns++;
-            continue;
-         }
-         RARCH_ERR("[TINYALSA]: Cannot read stream data.\n");
-         return -1;
-      }
-      return x.result;
-   }
-}
-
-/** Writes audio samples to PCM.
- * If the PCM has not been started, it is started in this function.
- * This function is only valid for PCMs opened with the @ref PCM_OUT flag.
- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
- * @param pcm A PCM handle.
- * @param data The audio sample array
- * @param count The number of bytes occupied by the sample array.
- * @return On success, this function returns zero; otherwise, a negative number.
- * @deprecated
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_write(struct pcm *pcm, const void *data, unsigned int count)
-{
-   return pcm_writei(pcm, data, pcm_bytes_to_frames(pcm, count));
-}
-
-/** Reads audio samples from PCM.
- * If the PCM has not been started, it is started in this function.
- * This function is only valid for PCMs opened with the @ref PCM_IN flag.
- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
- * @param pcm A PCM handle.
- * @param data The audio sample array
- * @param count The number of bytes occupied by the sample array.
- * @return On success, this function returns zero; otherwise, a negative number.
- * @deprecated
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_read(struct pcm *pcm, void *data, unsigned int count)
-{
-   return pcm_readi(pcm, data, pcm_bytes_to_frames(pcm, count));
-}
-#endif
-
-static struct pcm bad_pcm = {
-    -1                       /* fd */
-};
-
-/** Gets the hardware parameters of a PCM, without created a PCM handle.
- * @param card The card of the PCM.
- *  The default card is zero.
- * @param device The device of the PCM.
- *  The default device is zero.
- * @param flags Specifies whether the PCM is an input or output.
- *  May be one of the following:
- *   - @ref PCM_IN
- *   - @ref PCM_OUT
- * @return On success, the hardware parameters of the PCM; on failure, NULL.
- * @ingroup libtinyalsa-pcm
- */
-static struct pcm_params *pcm_params_get(unsigned int card, unsigned int device,
-      unsigned int flags)
-{
-   struct snd_pcm_hw_params *params;
-   char fn[256];
-   int fd;
-
-   snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
-         flags & PCM_IN ? 'c' : 'p');
-
-   fd = open(fn, O_RDWR|O_NONBLOCK);
-   if (fd < 0)
-   {
-      RARCH_ERR("[TINYALSA] Cannot open device '%s'\n", fn);
-      goto err_open;
-   }
-
-   params = (struct snd_pcm_hw_params*)
-      calloc(1, sizeof(struct snd_pcm_hw_params));
-
-   if (!params)
-      goto err_calloc;
-
-   param_init(params);
-   if (ioctl(fd, SNDRV_PCM_IOCTL_HW_REFINE, params))
-   {
-      RARCH_ERR("[TINYALSA] SNDRV_PCM_IOCTL_HW_REFINE error (%d)\n", errno);
-      goto err_hw_refine;
-   }
-
-   close(fd);
-
-   return (struct pcm_params *)params;
-
-err_hw_refine:
-   free(params);
-err_calloc:
-   close(fd);
-err_open:
-   return NULL;
-}
-
-/** Frees the hardware parameters returned by @ref pcm_params_get.
- * @param pcm_params Hardware parameters of a PCM.
- *  May be NULL.
- * @ingroup libtinyalsa-pcm
- */
-static void pcm_params_free(struct pcm_params *pcm_params)
-{
-   struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
-
-   if (params)
-      free(params);
-}
-
-#if 0
-/* Unused for now */
-
-/** Gets a mask from a PCM's hardware parameters.
- * @param pcm_params A PCM's hardware parameters.
- * @param param The parameter to get.
- * @return If @p pcm_params is NULL or @p param is not a mask, NULL is returned.
- *  Otherwise, the mask associated with @p param is returned.
- * @ingroup libtinyalsa-pcm
- */
-static const struct pcm_mask *pcm_params_get_mask(const struct pcm_params *pcm_params,
-      enum pcm_param param)
-{
-    int p;
-    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
-    if (!params)
-        return NULL;
-
-    p = pcm_param_to_alsa(param);
-    if (p < 0 || !param_is_mask(p))
-        return NULL;
-
-    return (const struct pcm_mask *)param_to_mask(params, p);
-}
-#endif
-
-static int pcm_param_to_alsa(enum pcm_param param)
-{
-   switch (param)
-   {
-      case PCM_PARAM_ACCESS:
-         return SNDRV_PCM_HW_PARAM_ACCESS;
-      case PCM_PARAM_FORMAT:
-         return SNDRV_PCM_HW_PARAM_FORMAT;
-      case PCM_PARAM_SUBFORMAT:
-         return SNDRV_PCM_HW_PARAM_SUBFORMAT;
-      case PCM_PARAM_SAMPLE_BITS:
-         return SNDRV_PCM_HW_PARAM_SAMPLE_BITS;
-      case PCM_PARAM_FRAME_BITS:
-         return SNDRV_PCM_HW_PARAM_FRAME_BITS;
-      case PCM_PARAM_CHANNELS:
-         return SNDRV_PCM_HW_PARAM_CHANNELS;
-      case PCM_PARAM_RATE:
-         return SNDRV_PCM_HW_PARAM_RATE;
-      case PCM_PARAM_PERIOD_TIME:
-         return SNDRV_PCM_HW_PARAM_PERIOD_TIME;
-      case PCM_PARAM_PERIOD_SIZE:
-         return SNDRV_PCM_HW_PARAM_PERIOD_SIZE;
-      case PCM_PARAM_PERIOD_BYTES:
-         return SNDRV_PCM_HW_PARAM_PERIOD_BYTES;
-      case PCM_PARAM_PERIODS:
-         return SNDRV_PCM_HW_PARAM_PERIODS;
-      case PCM_PARAM_BUFFER_TIME:
-         return SNDRV_PCM_HW_PARAM_BUFFER_TIME;
-      case PCM_PARAM_BUFFER_SIZE:
-         return SNDRV_PCM_HW_PARAM_BUFFER_SIZE;
-      case PCM_PARAM_BUFFER_BYTES:
-         return SNDRV_PCM_HW_PARAM_BUFFER_BYTES;
-      case PCM_PARAM_TICK_TIME:
-         return SNDRV_PCM_HW_PARAM_TICK_TIME;
-
-      default:
-         break;
-   }
-
-   return -1;
-}
-
-static unsigned int param_get_min(const struct snd_pcm_hw_params *p, int n)
-{
-    if (param_is_interval(n))
-    {
-        const struct snd_interval *i = param_get_interval(p, n);
-        return i->min;
-    }
-    return 0;
-}
-
-/** Get the minimum of a specified PCM parameter.
- * @param pcm_params A PCM parameters structure.
- * @param param The specified parameter to get the minimum of.
- * @returns On success, the parameter minimum.
- *  On failure, zero.
- */
-static unsigned int pcm_params_get_min(const struct pcm_params *pcm_params,
-      enum pcm_param param)
-{
-   struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
-   int p;
-
-   if (!params)
-      return 0;
-
-   p = pcm_param_to_alsa(param);
-   if (p < 0)
-      return 0;
-
-   return param_get_min(params, p);
-}
-
-static unsigned int param_get_max(const struct snd_pcm_hw_params *p, int n)
-{
-    if (param_is_interval(n))
-    {
-        const struct snd_interval *i = param_get_interval(p, n);
-        return i->max;
-    }
-    return 0;
-}
-
-/** Get the maximum of a specified PCM parameter.
- * @param pcm_params A PCM parameters structure.
- * @param param The specified parameter to get the maximum of.
- * @returns On success, the parameter maximum.
- *  On failure, zero.
- */
-static unsigned int pcm_params_get_max(const struct pcm_params *pcm_params,
-      enum pcm_param param)
-{
-   const struct snd_pcm_hw_params *params = (const struct snd_pcm_hw_params *)pcm_params;
-   int p;
-
-   if (!params)
-      return 0;
-
-   p = pcm_param_to_alsa(param);
-   if (p < 0)
-      return 0;
-
-   return param_get_max(params, p);
-}
-
-/** Stops a PCM.
- * @param pcm A PCM handle.
- * @return On success, zero; on failure, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_stop(struct pcm *pcm)
-{
-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DROP) < 0)
-   {
-      RARCH_ERR("[TINYALSA]: Cannot stop channel.\n");
-      return -1;
-   }
-
-   pcm->prepared = 0;
-   pcm->running = 0;
-   return 0;
-}
-
-static int pcm_params_can_pause(const struct pcm_params *pcm_params)
-{
-   const struct snd_pcm_hw_params *params = (const struct snd_pcm_hw_params *)pcm_params;
-
-   if (!params)
-      return 0;
-
-   return (params->info & SNDRV_PCM_INFO_PAUSE) ? 1 : 0;
-}
-
-static int pcm_pause(struct pcm *pcm, int enable)
-{
-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PAUSE, enable) < 0)
-      return -1;
-
-   return 0;
-}
-
-/** Closes a PCM returned by @ref pcm_open.
- * @param pcm A PCM returned by @ref pcm_open.
- *  May not be NULL.
- * @return Always returns zero.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_close(struct pcm *pcm)
-{
-   if (pcm == &bad_pcm)
-      return 0;
-
-   pcm_hw_munmap_status(pcm);
-
-   if (pcm->flags & PCM_MMAP)
-   {
-      pcm_stop(pcm);
-      munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
-   }
-
-   if (pcm->fd >= 0)
-      close(pcm->fd);
-   pcm->prepared = 0;
-   pcm->running = 0;
-   pcm->buffer_size = 0;
-   pcm->fd = -1;
-   free(pcm);
-   return 0;
-}
-
-/** Opens a PCM.
- * @param card The card that the pcm belongs to.
- *  The default card is zero.
- * @param device The device that the pcm belongs to.
- *  The default device is zero.
- * @param flags Specify characteristics and functionality about the pcm.
- *  May be a bitwise AND of the following:
- *   - @ref PCM_IN
- *   - @ref PCM_OUT
- *   - @ref PCM_MMAP
- *   - @ref PCM_NOIRQ
- *   - @ref PCM_MONOTONIC
- * @param config The hardware and software parameters to open the PCM with.
- * @returns A PCM structure.
- *  If an error occurs allocating memory for the PCM, NULL is returned.
- *  Otherwise, client code should check that the PCM opened properly by calling @ref pcm_is_ready.
- *  If @ref pcm_is_ready, check @ref pcm_get_error for more information.
- * @ingroup libtinyalsa-pcm
- */
-static struct pcm *pcm_open(unsigned int card, unsigned int device,
-      unsigned int flags, const struct pcm_config *config)
-{
-   int rc;
-   char fn[256];
-   struct snd_pcm_info info;
-   struct pcm *pcm = (struct pcm*)calloc(1, sizeof(struct pcm));
-   if (!pcm)
-      return &bad_pcm;
-
-   snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
-         flags & PCM_IN ? 'c' : 'p');
-
-   pcm->flags = flags;
-   pcm->fd    = open(fn, O_RDWR|O_NONBLOCK);
-   if (pcm->fd < 0)
-   {
-      RARCH_ERR("[TINYALSA]: cannot open device '%s'\n", fn);
-      return pcm;
-   }
-
-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info))
-   {
-      RARCH_ERR("[TINYALSA]: cannot get info.\n");
-      goto fail_close;
-   }
-   pcm->subdevice = info.subdevice;
-
-   if (pcm_set_config(pcm, config) != 0)
-      goto fail_close;
-
-   rc = pcm_hw_mmap_status(pcm);
-   if (rc < 0)
-   {
-      RARCH_ERR("[TINYALSA]: mmap status failed.\n");
-      goto fail;
-   }
-
-#ifdef SNDRV_PCM_IOCTL_TTSTAMP
-   if (pcm->flags & PCM_MONOTONIC)
-   {
-      int arg = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC;
-      rc      = ioctl(pcm->fd, SNDRV_PCM_IOCTL_TTSTAMP, &arg);
-      if (rc < 0)
-      {
-         RARCH_ERR("[TINYALSA]: Cannot set timestamp type.\n");
-         goto fail;
-      }
-   }
-#endif
-
-   pcm->underruns = 0;
-   return pcm;
-
-fail:
-   if (flags & PCM_MMAP)
-      munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
-fail_close:
-   close(pcm->fd);
-   pcm->fd = -1;
-   return pcm;
-}
-
-#if 0
-/* Unused for now */
-
-/** Opens a PCM by it's name.
- * @param name The name of the PCM.
- *  The name is given in the format: <i>hw</i>:<b>card</b>,<b>device</b>
- * @param flags Specify characteristics and functionality about the pcm.
- *  May be a bitwise AND of the following:
- *   - @ref PCM_IN
- *   - @ref PCM_OUT
- *   - @ref PCM_MMAP
- *   - @ref PCM_NOIRQ
- *   - @ref PCM_MONOTONIC
- * @param config The hardware and software parameters to open the PCM with.
- * @returns A PCM structure.
- *  If an error occurs allocating memory for the PCM, NULL is returned.
- *  Otherwise, client code should check that the PCM opened properly by calling @ref pcm_is_ready.
- *  If @ref pcm_is_ready, check @ref pcm_get_error for more information.
- * @ingroup libtinyalsa-pcm
- */
-static struct pcm *pcm_open_by_name(const char *name,
-      unsigned int flags,
-      const struct pcm_config *config)
-{
-  unsigned int card, device;
-  if ((name[0] != 'h')
-   || (name[1] != 'w')
-   || (name[2] != ':'))
-    return NULL;
-
-  if (sscanf(&name[3], "%u,%u", &card, &device) != 2)
-    return NULL;
-
-  return pcm_open(card, device, flags, config);
-}
-
-/** Links two PCMs.
- * After this function is called, the two PCMs will prepare, start and stop in sync (at the same time).
- * If an error occurs, the error message will be written to @p pcm1.
- * @param pcm1 A PCM handle.
- * @param pcm2 Another PCM handle.
- * @return On success, zero; on failure, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_link(struct pcm *pcm1, struct pcm *pcm2)
-{
-   int err = ioctl(pcm1->fd, SNDRV_PCM_IOCTL_LINK, pcm2->fd);
-   if (err == -1)
-   {
-      RARCH_ERR("[TINYALSA]: Cannot link PCM.\n");
-      return -1;
-   }
-   return 0;
-}
-
-/** Unlinks a PCM.
- * @see @ref pcm_link
- * @param pcm A PCM handle.
- * @return On success, zero; on failure, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_unlink(struct pcm *pcm)
-{
-   int err = ioctl(pcm->fd, SNDRV_PCM_IOCTL_UNLINK);
-   if (err == -1)
-   {
-      RARCH_ERR("[TINYALSA]: Cannot unlink PCM.\n");
-      return -1;
-   }
-   return 0;
-}
-#endif
-
-static int pcm_avail_update(struct pcm *pcm)
-{
-   pcm_sync_ptr(pcm, 0);
-   return pcm_mmap_avail(pcm);
-}
-
-#if 0
-/* No longer used */
-
-static int pcm_state(struct pcm *pcm)
-{
-   int err = pcm_sync_ptr(pcm, 0);
-   if (err < 0)
-      return err;
-
-   return pcm->mmap_status->state;
-}
-#endif
-
-/** Waits for frames to be available for read or write operations.
- * @param pcm A PCM handle.
- * @param timeout The maximum amount of time to wait for, in terms of milliseconds.
- * @returns If frames became available, one is returned.
- *  If a timeout occured, zero is returned.
- *  If an error occured, a negative number is returned.
- * @ingroup libtinyalsa-pcm
- */
-static int pcm_wait(struct pcm *pcm, int timeout)
-{
-   struct pollfd pfd;
-
-   pfd.fd     = pcm->fd;
-   pfd.events = POLLIN | POLLOUT | POLLERR | POLLNVAL;
-
-   do
-   {
-      /* let's wait for avail or timeout */
-      int err = poll(&pfd, 1, timeout);
-      if (err < 0)
-         return -errno;
-
-      /* timeout ? */
-      if (err == 0)
-         return 0;
-
-      /* have we been interrupted ? */
-      if (errno == -EINTR)
-         continue;
-
-      /* check for any errors */
-      if (pfd.revents & (POLLERR | POLLNVAL))
-      {
-         int cond = -1;
-
-         if (pcm->sync_ptr)
-         {
-            pcm->sync_ptr->flags = 0;
-            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SYNC_PTR, pcm->sync_ptr) >= 0)
-               cond = pcm->mmap_status->state;
-         }
-
-         switch (cond)
-         {
-            case PCM_STATE_XRUN:
-               return -EPIPE;
-            case PCM_STATE_SUSPENDED:
-               return -ESTRPIPE;
-            case PCM_STATE_DISCONNECTED:
-               return -ENODEV;
-            default:
-               break;
-         }
-
-         return -EIO;
-      }
-      /* poll again if fd not ready for IO */
-   } while (!(pfd.revents & (POLLIN | POLLOUT)));
-
-   return 1;
-}
-
-#if 0
-/* Unused for now */
-
-static int pcm_mmap_transfer(struct pcm *pcm, const void *buffer, unsigned int bytes)
-{
-   int err = 0, frames, avail;
-   unsigned int offset = 0, count;
-
-   if (bytes == 0)
-      return 0;
-
-   count = pcm_bytes_to_frames(pcm, bytes);
-
-   while (count > 0)
-   {
-      /* get the available space for writing new frames */
-      avail = pcm_avail_update(pcm);
-      if (avail < 0)
-      {
-         RARCH_ERR("[TINYALSA] Cannot determine available mmap frames");
-         return err;
-      }
-
-      /* start the audio if we reach the threshold */
-      if (!pcm->running &&
-            (pcm->buffer_size - avail) >= pcm->config.start_threshold)
-      {
-         if (pcm_start(pcm) < 0)
-         {
-            RARCH_ERR("[TINYALSA] Start error: hw 0x%x app 0x%x avail 0x%x\n",
-                  (unsigned int)pcm->mmap_status->hw_ptr,
-                  (unsigned int)pcm->mmap_control->appl_ptr,
-                  avail);
-            return -errno;
-         }
-      }
-
-      /* sleep until we have space to write new frames */
-      if (pcm->running &&
-            (unsigned int)avail < pcm->mmap_control->avail_min)
-      {
-         int time = -1;
-
-         if (pcm->flags & PCM_NOIRQ)
-            time = (pcm->buffer_size - avail - pcm->mmap_control->avail_min)
-               / pcm->noirq_frames_per_msec;
-
-         err = pcm_wait(pcm, time);
-         if (err < 0)
-         {
-            pcm->prepared = 0;
-            pcm->running = 0;
-            RARCH_ERR("[TINYALSA] Wait error: hw 0x%x app 0x%x avail 0x%x\n",
-                  (unsigned int)pcm->mmap_status->hw_ptr,
-                  (unsigned int)pcm->mmap_control->appl_ptr,
-                  avail);
-            pcm->mmap_control->appl_ptr = 0;
-            return err;
-         }
-         continue;
-      }
-
-      frames = count;
-      if (frames > avail)
-         frames = avail;
-
-      if (!frames)
-         break;
-
-      /* copy frames from buffer */
-      frames = pcm_mmap_transfer_areas(pcm, (void *)buffer, offset, frames);
-      if (frames < 0)
-      {
-         RARCH_ERR("[TINYALSA] Write error: hw 0x%x app 0x%x avail 0x%x\n",
-               (unsigned int)pcm->mmap_status->hw_ptr,
-               (unsigned int)pcm->mmap_control->appl_ptr,
-               avail);
-         return frames;
-      }
-
-      offset += frames;
-      count -= frames;
-   }
-
-   return 0;
-}
-
-static int pcm_mmap_write(struct pcm *pcm, const void *data, unsigned int count)
-{
-   if ((~pcm->flags) & (PCM_OUT | PCM_MMAP))
-      return -ENOSYS;
-
-   return pcm_mmap_transfer(pcm, (void *)data, count);
-}
-
-static int pcm_mmap_read(struct pcm *pcm, void *data, unsigned int count)
-{
-   if ((~pcm->flags) & (PCM_IN | PCM_MMAP))
-      return -ENOSYS;
-
-   return pcm_mmap_transfer(pcm, data, count);
-}
-
-/** Gets the delay of the PCM, in terms of frames.
- * @param pcm A PCM handle.
- * @returns On success, the delay of the PCM.
- *  On failure, a negative number.
- * @ingroup libtinyalsa-pcm
- */
-static long pcm_get_delay(struct pcm *pcm)
-{
-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DELAY, &pcm->pcm_delay) < 0)
-      return -1;
-
-   return pcm->pcm_delay;
-}
-
-static int pcm_mmap_transfer_areas(struct pcm *pcm, char *buf,
-      unsigned int offset, unsigned int size)
-{
-   void *pcm_areas;
-   int commit;
-   unsigned int pcm_offset, frames, count = 0;
-
-   while (size > 0)
-   {
-      frames = size;
-      pcm_mmap_begin(pcm, &pcm_areas, &pcm_offset, &frames);
-      pcm_areas_copy(pcm, pcm_offset, buf, offset, frames);
-      commit = pcm_mmap_commit(pcm, pcm_offset, frames);
-      if (commit < 0)
-      {
-         RARCH_ERR("[TINYALSA}: failed to commit %d frames.\n", frames);
-         return commit;
-      }
-
-      offset += commit;
-      count += commit;
-      size -= commit;
-   }
-   return count;
-}
-#endif
-
-/* End of implementation tinyalsa pcm */
-
 typedef struct tinyalsa
 {
-   struct pcm        *pcm;
-   struct pcm_params *params;
-   size_t            buffer_size;
-   bool              nonblock;
-   bool              has_float;
-   bool              can_pause;
-   bool              is_paused;
-   unsigned int      frame_bits;
+	unsigned int card;
+	unsigned int device;
+	struct pcm_config config;
+	struct pcm *pcm;
+	size_t buffer_size;
+	bool nonblock;
+	bool use_mmap;
 } tinyalsa_t;
 
-#define BYTES_TO_FRAMES(bytes, frame_bits)  ((bytes) * 8 / frame_bits)
-#define FRAMES_TO_BYTES(frames, frame_bits) ((frames) * frame_bits / 8)
-
-static void * tinyalsa_init(const char *devicestr, unsigned rate,
-      unsigned latency, unsigned block_frames,
-      unsigned *new_rate)
+static void * tinyalsa_init(const char *devicestr, unsigned rate, unsigned latency, unsigned block_frames, unsigned *new_rate)
 {
-   unsigned int card            = 0;
-   unsigned int device          = 0;
-   unsigned int frames_per_ms   = 0;
-   unsigned int orig_rate       = rate;
-   unsigned int max_rate, min_rate, buffer_size;
-   float initial_latency;
-
-   struct pcm_config         config;
-
-   tinyalsa_t *tinyalsa      = (tinyalsa_t*)calloc(1, sizeof(tinyalsa_t));
+	unsigned int card = 0;
+	unsigned int device = 0;
+	unsigned int frames_per_ms = 0;
+	unsigned int orig_rate = rate;
+	unsigned int max_rate, min_rate, buffer_size;
+	struct pcm_params *params;
+	float initial_latency;
 
-   if (!tinyalsa)
-      return NULL;
+	tinyalsa_t *tinyalsa = (tinyalsa_t*)calloc(1, sizeof(tinyalsa_t));
 
-   if (devicestr)
-      sscanf(devicestr, "%u,%u", &card, &device);
+	if (!tinyalsa)
+		return NULL;
 
-   RARCH_LOG("[TINYALSA]: Using card: %u, device: %u.\n", card, device);
+	if (devicestr)
+		sscanf(devicestr, "%u,%u", &card, &device);
 
-   tinyalsa->params = pcm_params_get(card, device, PCM_OUT);
-   if (!tinyalsa->params)
-   {
-      RARCH_ERR("[TINYALSA]: params: Cannot open audio device.\n");
-      goto error;
-   }
+	tinyalsa->card = card;
+	tinyalsa->device = device;
+	tinyalsa->use_mmap = getenv("ALSA_FORCE_MMAP") != NULL;
 
-   if (pcm_params_can_pause(tinyalsa->params))
-      tinyalsa->can_pause = true;
+	RARCH_LOG("[TINYALSA]: Using card: %u, device: %u.\n", card, device);
 
-   min_rate = pcm_params_get_min(tinyalsa->params, PCM_PARAM_RATE);
-   max_rate = pcm_params_get_max(tinyalsa->params, PCM_PARAM_RATE);
-
-   if (!(rate >= min_rate && rate <= max_rate))
-   {
-      RARCH_WARN("[TINYALSA]: Sample rate cannot be larger than %uHz "\
-                 "or smaller than %uHz.\n", max_rate, min_rate);
-      RARCH_WARN("[TINYALSA]: Trying to set a valid sample rate.\n");
+	params = pcm_params_get(card, device, PCM_OUT);
+	if (!params)
+	{
+		RARCH_ERR("[TINYALSA]: params: Cannot open audio device.\n");
+		goto error;
+	}
 
-      if (rate > max_rate)
-         rate = max_rate;
-      else if (rate < min_rate)
-         rate = min_rate;
-   }
+	min_rate = pcm_params_get_min(params, PCM_PARAM_RATE);
+	max_rate = pcm_params_get_max(params, PCM_PARAM_RATE);
 
-   if (orig_rate != rate)
-      *new_rate = rate;
+	if (!(rate >= min_rate && rate <= max_rate))
+	{
+		RARCH_WARN("[TINYALSA]: Sample rate cannot be larger than %uHz or smaller than %uHz.\n", max_rate, min_rate);
+		RARCH_WARN("[TINYALSA]: Trying to set a valid sample rate.\n");
 
-   config.rate              = rate;
-   config.format            = is_little_endian() ?\
-                              PCM_FORMAT_S16_LE : PCM_FORMAT_S16_BE;
-   config.channels          = 2;
-   config.period_size       = 1024;
-   config.period_count      = 4;
-   config.start_threshold   = config.period_size;
-   config.stop_threshold    = 0;
-   config.silence_threshold = 0;
+		if (rate > max_rate)
+			rate = max_rate;
+		else if (rate < min_rate)
+			rate = min_rate;
+	}
 
-   tinyalsa->pcm = pcm_open(card, device, PCM_OUT, &config);
+	if (orig_rate != rate)
+		*new_rate = rate;
 
-   if (!tinyalsa->pcm)
-   {
-      RARCH_ERR("[TINYALSA]: Failed to allocate memory for pcm.\n");
-      goto error;
-   }
-   else if (!pcm_is_ready(tinyalsa->pcm))
-   {
-      RARCH_ERR("[TINYALSA]: Cannot open audio device.\n");
-      goto error;
-   }
+	unsigned int period_size = 1024;
+	char * period_size_override = getenv("ALSA_DEFAULT_PERIOD_SIZE");
+	if (period_size_override != NULL)
+	{
+		period_size = (unsigned int)atoi(period_size_override);
+	}
 
-   buffer_size           = pcm_get_buffer_size(tinyalsa->pcm);
-   tinyalsa->buffer_size = pcm_frames_to_bytes(tinyalsa->pcm, buffer_size);
-   tinyalsa->frame_bits  = pcm_format_to_bits(config.format) * 2;
+	tinyalsa->config.rate = rate;
+	tinyalsa->config.format = is_little_endian() ? PCM_FORMAT_S16_LE : PCM_FORMAT_S16_BE;
+	tinyalsa->config.channels = 2;
+	tinyalsa->config.period_size = period_size;
+	tinyalsa->config.period_count = 4;
+	tinyalsa->config.start_threshold = tinyalsa->config.period_size;
+	tinyalsa->config.stop_threshold = tinyalsa->use_mmap ? -1 : 0;
+	tinyalsa->config.avail_min = tinyalsa->config.period_size;
+	tinyalsa->config.silence_threshold = tinyalsa->config.period_size * tinyalsa->config.period_count;
+	tinyalsa->config.silence_size = 0;
+
+	tinyalsa->pcm = pcm_open(card, device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP | PCM_NOIRQ | PCM_MONOTONIC | PCM_NORESTART : 0), &tinyalsa->config);
+
+	if (!tinyalsa->pcm)
+	{
+		RARCH_ERR("[TINYALSA]: Failed to allocate memory for pcm.\n");
+		goto error;
+	}
+	else if (!pcm_is_ready(tinyalsa->pcm))
+	{
+		RARCH_ERR("[TINYALSA]: Cannot open audio device.\n");
+		goto error;
+	}
 
-   initial_latency       = (float)(buffer_size * 1000) / (float)(rate * 4);
-   frames_per_ms         = buffer_size / initial_latency;
+	buffer_size = pcm_get_buffer_size(tinyalsa->pcm);
+	tinyalsa->buffer_size = pcm_frames_to_bytes(tinyalsa->pcm, buffer_size);
 
-   if (latency < (unsigned int)initial_latency)
-   {
-      RARCH_WARN("[TINYALSA]: Cannot have a latency less than %ums. "\
-                 "Defaulting to 64ms.\n", (unsigned int)initial_latency);
-      latency = 64;
-   }
+	initial_latency = (float)(buffer_size * 1000) / (float)(rate * 4);
+	frames_per_ms = buffer_size / initial_latency;
 
-   latency               -= (unsigned int)initial_latency;
-   buffer_size           += latency * frames_per_ms;
+	if (latency < (unsigned int)initial_latency)
+	{
+		RARCH_WARN("[TINYALSA]: Cannot have a latency less than %ums. Defaulting to 64ms.\n", (unsigned int)initial_latency);
+		latency = initial_latency;
+	}
 
-   tinyalsa->has_float   = false;
+	latency -= (unsigned int)initial_latency;
+	buffer_size += latency * frames_per_ms;
 
-   RARCH_LOG("[TINYALSA]: Can pause: %s.\n", tinyalsa->can_pause ? "yes" : "no");
-   RARCH_LOG("[TINYALSA]: Audio rate: %uHz.\n", config.rate);
-   RARCH_LOG("[TINYALSA]: Buffer size: %u frames.\n", buffer_size);
-   RARCH_LOG("[TINYALSA]: Buffer size: %u bytes.\n", (unsigned int)tinyalsa->buffer_size);
-   RARCH_LOG("[TINYALSA]: Frame  size: %u bytes.\n", tinyalsa->frame_bits / 8);
-   RARCH_LOG("[TINYALSA]: Latency: %ums.\n", buffer_size * 1000 / (rate * 4));
+	RARCH_LOG("[TINYALSA]: Audio rate: %uHz.\n", tinyalsa->config.rate);
+	RARCH_LOG("[TINYALSA]: Buffer size: %u frames.\n", buffer_size);
+	RARCH_LOG("[TINYALSA]: Buffer size: %u bytes.\n", (unsigned int)tinyalsa->buffer_size);
+	RARCH_LOG("[TINYALSA]: Frame size: %u bytes.\n", pcm_frames_to_bytes(tinyalsa->pcm, 1));
+	RARCH_LOG("[TINYALSA]: Latency: %ums.\n", buffer_size * 1000 / (rate * 4));
 
-   pcm_params_free(tinyalsa->params);
+	pcm_params_free(params);
 
-   return tinyalsa;
+	return tinyalsa;
 
 error:
-   RARCH_ERR("[TINYALSA]: Failed to initialize tinyalsa driver.\n");
+	RARCH_ERR("[TINYALSA]: Failed to initialize tinyalsa driver.\n");
 
-   if (tinyalsa->params)
-      pcm_params_free(tinyalsa->params);
+	if (params)
+		pcm_params_free(params);
 
-   if (tinyalsa)
-      free(tinyalsa);
+	if (tinyalsa)
+		free(tinyalsa);
 
-   return NULL;
+	return NULL;
 }
 
-static ssize_t
-tinyalsa_write(void *data, const void *buf_, size_t size_)
+static ssize_t tinyalsa_write(void *data, const void *buf_, size_t size_)
 {
-   tinyalsa_t *tinyalsa      = (tinyalsa_t*)data;
-   const uint8_t *buf        = (const uint8_t*)buf_;
-   snd_pcm_sframes_t written = 0;
-   snd_pcm_sframes_t size    = BYTES_TO_FRAMES(size_, tinyalsa->frame_bits);
-   size_t frames_size        = tinyalsa->has_float ? sizeof(float) : sizeof(int16_t);
-
-   if (tinyalsa->nonblock)
-   {
-      while (size)
-      {
-         snd_pcm_sframes_t frames   = pcm_writei(tinyalsa->pcm, buf, size);
-
-         if (frames < 0)
-            pcm_stop(tinyalsa->pcm);
-
-         written += frames;
-         buf     += (frames << 1) * frames_size;
-         size    -= frames;
-      }
-   }
-   else
-   {
-      while (size)
-      {
-         snd_pcm_sframes_t frames;
-         pcm_wait(tinyalsa->pcm, -1);
-
-         frames   = pcm_writei(tinyalsa->pcm, buf, size);
-
-         if (frames < 0)
-            return -1;
-
-         written += frames;
-         buf     += (frames << 1) * frames_size;
-         size    -= frames;
-      }
-   }
-
-   return written;
+	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+	const uint8_t *buf = (const uint8_t*)buf_;
+	snd_pcm_sframes_t written = 0;
+	size_t frames_size = sizeof(int16_t);
+
+	if (tinyalsa->pcm)
+	{
+		snd_pcm_sframes_t size = pcm_bytes_to_frames(tinyalsa->pcm, size_);
+
+		while (size)
+		{
+			snd_pcm_sframes_t frames = pcm_writei(tinyalsa->pcm, buf, size);
+
+			if (frames < 0)
+			{
+				if (errno == EAGAIN)
+				{
+					if (tinyalsa->nonblock)
+					{
+						break;
+					}
+
+					continue;
+				}
+
+				break;
+			}
+
+			written += frames;
+			buf += (frames << 1) * frames_size;
+			size -= frames;
+		}
+	}
 
+	return written;
 }
 
-static bool
-tinyalsa_stop(void *data)
+static bool tinyalsa_start(void *data, bool is_shutdown)
 {
 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
 
-	if (tinyalsa->can_pause && !tinyalsa->is_paused)
-   {
-		int ret = pcm_pause(tinyalsa->pcm, 1);
-		if (ret < 0)
-			return false;
-
-		tinyalsa->is_paused = true;
+	while (tinyalsa->pcm == NULL)
+	{
+		tinyalsa->pcm = (int *)pcm_open(tinyalsa->card, tinyalsa->device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP | PCM_NOIRQ | PCM_MONOTONIC | PCM_NORESTART : 0), &tinyalsa->config);
 	}
 
-	return true;
+	return tinyalsa->pcm != NULL;
 }
 
-static bool
-tinyalsa_alive(void *data)
+static bool tinyalsa_stop(void *data)
 {
 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
 
-	if (tinyalsa)
-		return !tinyalsa->is_paused;
+	if (tinyalsa->pcm != NULL)
+	{
+		pcm_close(tinyalsa->pcm);
+		tinyalsa->pcm = NULL;
+	}
 
-	return false;
+	return true;
 }
 
-static bool
-tinyalsa_start(void *data, bool is_shutdown)
+static bool tinyalsa_alive(void *data)
 {
 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
 
-	if (tinyalsa->can_pause && tinyalsa->is_paused)
-   {
-		int ret = pcm_pause(tinyalsa->pcm, 0);
-
-		if (ret < 0)
-      {
-			RARCH_ERR("[TINYALSA]: Failed to unpause.\n");
-			return false;
-		}
-
-		tinyalsa->is_paused = false;
-	}
-
-	return true;
+	return tinyalsa != NULL && tinyalsa->pcm != NULL;
 }
 
 static void tinyalsa_set_nonblock_state(void *data, bool state)
 {
 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+
 	tinyalsa->nonblock = state;
 }
 
 static bool tinyalsa_use_float(void *data)
 {
-	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
-
-	return tinyalsa->has_float;
+	return false;
 }
 
 static void tinyalsa_free(void *data)
 {
-   tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
 
-   if (tinyalsa)
-   {
-      if (tinyalsa->pcm)
-         pcm_close(tinyalsa->pcm);
+	if (tinyalsa)
+	{
+		if (tinyalsa->pcm != NULL)
+		{
+			pcm_close(tinyalsa->pcm);
+			tinyalsa->pcm = NULL;
+		}
 
-      tinyalsa->pcm = NULL;
-      free(tinyalsa);
-   }
+		free(tinyalsa);
+	}
 }
 
 static size_t tinyalsa_write_avail(void *data)
 {
-   tinyalsa_t *alsa        = (tinyalsa_t*)data;
-   snd_pcm_sframes_t avail = pcm_avail_update(alsa->pcm);
+	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
 
-   if (avail < 0)
-      return alsa->buffer_size;
+	if (tinyalsa->pcm)
+	{
+		snd_pcm_sframes_t avail = pcm_avail_update(tinyalsa->pcm);
 
-   return FRAMES_TO_BYTES(avail, alsa->frame_bits);
+		if (avail >= 0)
+		{
+			return pcm_frames_to_bytes(tinyalsa->pcm, avail);
+		}
+	}
+
+	return tinyalsa->buffer_size;
 }
 
 static size_t tinyalsa_buffer_size(void *data)
@@ -2414,17 +293,17 @@ static size_t tinyalsa_buffer_size(void *data)
 }
 
 audio_driver_t audio_tinyalsa = {
-	tinyalsa_init,               /* AUDIO_init              */
-	tinyalsa_write,              /* AUDIO_write             */
-	tinyalsa_stop,               /* AUDIO_stop              */
-	tinyalsa_start,              /* AUDIO_start             */
-	tinyalsa_alive,              /* AUDIO_alive             */
-	tinyalsa_set_nonblock_state, /* AUDIO_set_nonblock_sate */
-	tinyalsa_free,               /* AUDIO_free              */
-	tinyalsa_use_float,          /* AUDIO_use_float         */
-	"tinyalsa",                  /* "AUDIO"                 */
-	NULL,                        /* AUDIO_device_list_new   */ /*TODO*/
-	NULL,                        /* AUDIO_device_list_free  */ /*TODO*/
-   tinyalsa_write_avail,        /* AUDIO_write_avail       */ /*TODO*/
-	tinyalsa_buffer_size,        /* AUDIO_buffer_size       */ /*TODO*/
+	tinyalsa_init,					// AUDIO_init
+	tinyalsa_write,					// AUDIO_write
+	tinyalsa_stop,					// AUDIO_stop
+	tinyalsa_start,					// AUDIO_start
+	tinyalsa_alive,					// AUDIO_alive
+	tinyalsa_set_nonblock_state,	// AUDIO_set_nonblock_sate
+	tinyalsa_free,					// AUDIO_free
+	tinyalsa_use_float,				// AUDIO_use_float
+	"tinyalsa",						// "AUDIO"
+	NULL,							// AUDIO_device_list_new
+	NULL,							// AUDIO_device_list_free
+	tinyalsa_write_avail,			// AUDIO_write_avail
+	tinyalsa_buffer_size,			// AUDIO_buffer_size
 };
diff --git a/oldpatches/retroarch/0001-make-compiler-variable-overwritable.patch b/oldpatches/retroarch/0001-make-compiler-variable-overwritable.patch
new file mode 100644
index 0000000..0b2e9f6
--- /dev/null
+++ b/oldpatches/retroarch/0001-make-compiler-variable-overwritable.patch
@@ -0,0 +1,53 @@
+From cbbd5cb51e2e460710fba0c7f71b70570790507c Mon Sep 17 00:00:00 2001
+From: Adam Duskett <Aduskett@gmail.com>
+Date: Sat, 4 Apr 2020 23:18:36 -0700
+Subject: [PATCH] make-compiler-variable-overwritable
+
+Allow cross compilers such as buildroot or Yocto for specify a compiler.
+
+Signed-off-by: Adam Duskett <Aduskett@gmail.com>
+---
+ gfx/video_filters/Makefile                 | 8 ++++----
+ libretro-common/audio/dsp_filters/Makefile | 6 +++---
+ 2 files changed, 7 insertions(+), 7 deletions(-)
+
+diff --git a/gfx/video_filters/Makefile b/gfx/video_filters/Makefile
+index 2ba8930..eb5f24c 100644
+--- a/gfx/video_filters/Makefile
++++ b/gfx/video_filters/Makefile
+@@ -1,10 +1,10 @@
+-compiler    := gcc
+-extra_flags :=
+-use_neon    := 0
++compiler    ?= gcc
++extra_flags ?=
++use_neon    ?= 0
+ release	    := release
+ DYLIB	    := so
+ PREFIX      := /usr
+-INSTALLDIR  := $(PREFIX)/lib/retroarch/filters/video
++INSTALLDIR  ?= $(PREFIX)/lib/retroarch/filters/video
+ 
+ ifeq ($(platform),)
+    platform = unix
+diff --git a/libretro-common/audio/dsp_filters/Makefile b/libretro-common/audio/dsp_filters/Makefile
+index 02e049d..08bf6ed 100644
+--- a/libretro-common/audio/dsp_filters/Makefile
++++ b/libretro-common/audio/dsp_filters/Makefile
+@@ -1,10 +1,10 @@
+-compiler    := gcc
++compiler    ?= gcc
+ extra_flags :=
+ use_neon    := 0
+ build       = release
+ DYLIB	      := so
+-PREFIX      := /usr
+-INSTALLDIR  := $(PREFIX)/lib/retroarch/filters/audio
++PREFIX      ?= /usr
++INSTALLDIR ?= $(PREFIX)/lib/retroarch/filters/audio
+ 
+ ifeq ($(platform),)
+    platform = unix
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0002-Commonize-tinyalsa-driver.patch b/oldpatches/retroarch/0002-Commonize-tinyalsa-driver.patch
new file mode 100644
index 0000000..fd26165
--- /dev/null
+++ b/oldpatches/retroarch/0002-Commonize-tinyalsa-driver.patch
@@ -0,0 +1,2586 @@
+From ab290ef2881347fccceaf72b2b120549a0faf78e Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Wed, 3 May 2023 15:53:05 +0200
+Subject: [PATCH 1/6] Commonize tinyalsa driver
+
+---
+ audio/drivers/tinyalsa.c | 2478 +++-----------------------------------
+ 1 file changed, 173 insertions(+), 2305 deletions(-)
+
+diff --git a/audio/drivers/tinyalsa.c b/audio/drivers/tinyalsa.c
+index fee4174..7cf458d 100644
+--- a/audio/drivers/tinyalsa.c
++++ b/audio/drivers/tinyalsa.c
+@@ -1,31 +1,3 @@
+-/* pcm.c
+-**
+-** Copyright 2011, The Android Open Source Project
+-**
+-** Redistribution and use in source and binary forms, with or without
+-** modification, are permitted provided that the following conditions are met:
+-**     * Redistributions of source code must retain the above copyright
+-**       notice, this list of conditions and the following disclaimer.
+-**     * Redistributions in binary form must reproduce the above copyright
+-**       notice, this list of conditions and the following disclaimer in the
+-**       documentation and/or other materials provided with the distribution.
+-**     * Neither the name of The Android Open Source Project nor the names of
+-**       its contributors may be used to endorse or promote products derived
+-**       from this software without specific prior written permission.
+-**
+-** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+-** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+-** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+-** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+-** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+-** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+-** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+-** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+-** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+-** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+-** DAMAGE.
+-*/
+-
+ /*  RetroArch - A frontend for libretro.
+  *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+  *  Copyright (C) 2011-2017 - Daniel De Matteis
+@@ -64,2346 +36,242 @@
+ #include <retro_inline.h>
+ #include <retro_endianness.h>
+ 
++#include <sound/asound.h>
++#include <tinyalsa/asoundlib.h>
++
+ #include "../audio_driver.h"
+ #include "../../verbosity.h"
+ 
+-/* Implementation tinyalsa pcm */
+-
+-/** A flag that specifies that the PCM is an output.
+- * May not be bitwise AND'd with @ref PCM_IN.
+- * Used in @ref pcm_open.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define PCM_OUT 0x00000000
+-
+-/** Specifies that the PCM is an input.
+- * May not be bitwise AND'd with @ref PCM_OUT.
+- * Used in @ref pcm_open.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define PCM_IN 0x10000000
+-
+-/** Specifies that the PCM will use mmap read and write methods.
+- * Used in @ref pcm_open.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define PCM_MMAP 0x00000001
+-
+-/** Specifies no interrupt requests.
+- * May only be bitwise AND'd with @ref PCM_MMAP.
+- * Used in @ref pcm_open.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define PCM_NOIRQ 0x00000002
+-
+-/** When set, calls to @ref pcm_write
+- * for a playback stream will not attempt
+- * to restart the stream in the case of an
+- * underflow, but will return -EPIPE instead.
+- * After the first -EPIPE error, the stream
+- * is considered to be stopped, and a second
+- * call to pcm_write will attempt to restart
+- * the stream.
+- * Used in @ref pcm_open.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define PCM_NORESTART 0x00000004
+-
+-/** Specifies monotonic timestamps.
+- * Used in @ref pcm_open.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define PCM_MONOTONIC 0x00000008
+-
+-/** For inputs, this means the PCM is recording audio samples.
+- * For outputs, this means the PCM is playing audio samples.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define	PCM_STATE_RUNNING	0x03
+-
+-/** For inputs, this means an overrun occured.
+- * For outputs, this means an underrun occured.
+- */
+-#define	PCM_STATE_XRUN 0x04
+-
+-/** For outputs, this means audio samples are played.
+- * A PCM is in a draining state when it is coming to a stop.
+- */
+-#define	PCM_STATE_DRAINING 0x05
+-
+-/** Means a PCM is suspended.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define	PCM_STATE_SUSPENDED 0x07
+-
+-/** Means a PCM has been disconnected.
+- * @ingroup libtinyalsa-pcm
+- */
+-#define	PCM_STATE_DISCONNECTED 0x08
+-
+-#define SNDRV_CHMAP_POSITION_MASK	0xffff
+-#define SNDRV_CHMAP_PHASE_INVERSE	(0x01 << 16)
+-#define SNDRV_CHMAP_DRIVER_SPEC		(0x02 << 16)
+-#define SNDRV_PCM_IOCTL_PVERSION	_IOR('A', 0x00, int)
+-#define SNDRV_PCM_IOCTL_INFO		_IOR('A', 0x01, struct snd_pcm_info)
+-#define SNDRV_PCM_IOCTL_TSTAMP		_IOW('A', 0x02, int)
+-#define SNDRV_PCM_IOCTL_TTSTAMP		_IOW('A', 0x03, int)
+-#define SNDRV_PCM_IOCTL_HW_REFINE	_IOWR('A', 0x10, struct snd_pcm_hw_params)
+-#define SNDRV_PCM_IOCTL_HW_PARAMS	_IOWR('A', 0x11, struct snd_pcm_hw_params)
+-#define SNDRV_PCM_IOCTL_HW_FREE		_IO('A', 0x12)
+-#define SNDRV_PCM_IOCTL_SW_PARAMS	_IOWR('A', 0x13, struct snd_pcm_sw_params)
+-#define SNDRV_PCM_IOCTL_STATUS		_IOR('A', 0x20, struct snd_pcm_status)
+-#define SNDRV_PCM_IOCTL_DELAY		_IOR('A', 0x21, snd_pcm_sframes_t)
+-#define SNDRV_PCM_IOCTL_HWSYNC		_IO('A', 0x22)
+-#define SNDRV_PCM_IOCTL_SYNC_PTR	_IOWR('A', 0x23, struct snd_pcm_sync_ptr)
+-#define SNDRV_PCM_IOCTL_CHANNEL_INFO	_IOR('A', 0x32, struct snd_pcm_channel_info)
+-#define SNDRV_PCM_IOCTL_PREPARE		_IO('A', 0x40)
+-#define SNDRV_PCM_IOCTL_RESET		_IO('A', 0x41)
+-#define SNDRV_PCM_IOCTL_START		_IO('A', 0x42)
+-#define SNDRV_PCM_IOCTL_DROP		_IO('A', 0x43)
+-#define SNDRV_PCM_IOCTL_DRAIN		_IO('A', 0x44)
+-#define SNDRV_PCM_IOCTL_PAUSE		_IOW('A', 0x45, int)
+-#define SNDRV_PCM_IOCTL_REWIND		_IOW('A', 0x46, snd_pcm_uframes_t)
+-#define SNDRV_PCM_IOCTL_RESUME		_IO('A', 0x47)
+-#define SNDRV_PCM_IOCTL_XRUN		_IO('A', 0x48)
+-#define SNDRV_PCM_IOCTL_FORWARD		_IOW('A', 0x49, snd_pcm_uframes_t)
+-#define SNDRV_PCM_IOCTL_WRITEI_FRAMES	_IOW('A', 0x50, struct snd_xferi)
+-#define SNDRV_PCM_IOCTL_READI_FRAMES	_IOR('A', 0x51, struct snd_xferi)
+-#define SNDRV_PCM_IOCTL_WRITEN_FRAMES	_IOW('A', 0x52, struct snd_xfern)
+-#define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)
+-#define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)
+-#define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)
+-
+-#define	SNDRV_PCM_ACCESS_MMAP_INTERLEAVED	(( tinyalsa_snd_pcm_access_t) 0) /* interleaved mmap */
+-#define	SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED	(( tinyalsa_snd_pcm_access_t) 1) /* noninterleaved mmap */
+-#define	SNDRV_PCM_ACCESS_MMAP_COMPLEX		(( tinyalsa_snd_pcm_access_t) 2) /* complex mmap */
+-#define	SNDRV_PCM_ACCESS_RW_INTERLEAVED		(( tinyalsa_snd_pcm_access_t) 3) /* readi/writei */
+-#define	SNDRV_PCM_ACCESS_RW_NONINTERLEAVED	(( tinyalsa_snd_pcm_access_t) 4) /* readn/writen */
+-#define	SNDRV_PCM_ACCESS_LAST		SNDRV_PCM_ACCESS_RW_NONINTERLEAVED
+-
+-#define	SNDRV_PCM_SUBFORMAT_STD		(( tinyalsa_snd_pcm_subformat_t) 0)
+-#define	SNDRV_PCM_SUBFORMAT_LAST	SNDRV_PCM_SUBFORMAT_STD
+-
+-#define	SNDRV_PCM_SUBFORMAT_STD		(( tinyalsa_snd_pcm_subformat_t) 0)
+-#define	SNDRV_PCM_SUBFORMAT_LAST	SNDRV_PCM_SUBFORMAT_STD
+-#define SNDRV_PCM_INFO_MMAP		0x00000001	/* hardware supports mmap */
+-#define SNDRV_PCM_INFO_MMAP_VALID	0x00000002	/* period data are valid during transfer */
+-#define SNDRV_PCM_INFO_DOUBLE		0x00000004	/* Double buffering needed for PCM start/stop */
+-#define SNDRV_PCM_INFO_BATCH		0x00000010	/* double buffering */
+-#define SNDRV_PCM_INFO_INTERLEAVED	0x00000100	/* channels are interleaved */
+-#define SNDRV_PCM_INFO_NONINTERLEAVED	0x00000200	/* channels are not interleaved */
+-#define SNDRV_PCM_INFO_COMPLEX		0x00000400	/* complex frame organization (mmap only) */
+-#define SNDRV_PCM_INFO_BLOCK_TRANSFER	0x00010000	/* hardware transfer block of samples */
+-#define SNDRV_PCM_INFO_OVERRANGE	0x00020000	/* hardware supports ADC (capture) overrange detection */
+-#define SNDRV_PCM_INFO_RESUME		0x00040000	/* hardware supports stream resume after suspend */
+-#define SNDRV_PCM_INFO_PAUSE		0x00080000	/* pause ioctl is supported */
+-#define SNDRV_PCM_INFO_HALF_DUPLEX	0x00100000	/* only half duplex */
+-#define SNDRV_PCM_INFO_JOINT_DUPLEX	0x00200000	/* playback and capture stream are somewhat correlated */
+-#define SNDRV_PCM_INFO_SYNC_START	0x00400000	/* pcm support some kind of sync go */
+-#define SNDRV_PCM_INFO_NO_PERIOD_WAKEUP	0x00800000	/* period wakeup can be disabled */
+-#define SNDRV_PCM_INFO_HAS_WALL_CLOCK   0x01000000      /* has audio wall clock for audio/system time sync */
+-#define SNDRV_PCM_INFO_FIFO_IN_FRAMES	0x80000000	/* internal kernel flag - FIFO size is in frames */
+-#define	SNDRV_PCM_STATE_OPEN		(( tinyalsa_snd_pcm_state_t) 0) /* stream is open */
+-#define	SNDRV_PCM_STATE_SETUP		(( tinyalsa_snd_pcm_state_t) 1) /* stream has a setup */
+-#define	SNDRV_PCM_STATE_PREPARED	(( tinyalsa_snd_pcm_state_t) 2) /* stream is ready to start */
+-#define	SNDRV_PCM_STATE_RUNNING		(( tinyalsa_snd_pcm_state_t) 3) /* stream is running */
+-#define	SNDRV_PCM_STATE_XRUN		(( tinyalsa_snd_pcm_state_t) 4) /* stream reached an xrun */
+-#define	SNDRV_PCM_STATE_DRAINING	(( tinyalsa_snd_pcm_state_t) 5) /* stream is draining */
+-#define	SNDRV_PCM_STATE_PAUSED		(( tinyalsa_snd_pcm_state_t) 6) /* stream is paused */
+-#define	SNDRV_PCM_STATE_SUSPENDED	(( tinyalsa_snd_pcm_state_t) 7) /* hardware is suspended */
+-#define	SNDRV_PCM_STATE_DISCONNECTED	(( tinyalsa_snd_pcm_state_t) 8) /* hardware is disconnected */
+-#define	SNDRV_PCM_STATE_LAST		SNDRV_PCM_STATE_DISCONNECTED
+-
+-#define	SNDRV_PCM_HW_PARAM_ACCESS	         0	/* Access type */
+-#define	SNDRV_PCM_HW_PARAM_FORMAT	         1	/* Format */
+-#define	SNDRV_PCM_HW_PARAM_SUBFORMAT	      2	/* Subformat */
+-#define	SNDRV_PCM_HW_PARAM_FIRST_MASK	      SNDRV_PCM_HW_PARAM_ACCESS
+-#define	SNDRV_PCM_HW_PARAM_LAST_MASK	      SNDRV_PCM_HW_PARAM_SUBFORMAT
+-#define	SNDRV_PCM_HW_PARAM_SAMPLE_BITS	   8	/* Bits per sample */
+-#define	SNDRV_PCM_HW_PARAM_FRAME_BITS	      9	/* Bits per frame */
+-#define	SNDRV_PCM_HW_PARAM_CHANNELS	      10	/* Channels */
+-#define	SNDRV_PCM_HW_PARAM_RATE		         11	/* Approx rate */
+-#define	SNDRV_PCM_HW_PARAM_PERIOD_TIME	   12	/* Approx distance between interrupts in us */
+-#define	SNDRV_PCM_HW_PARAM_PERIOD_SIZE	   13	/* Approx frames between interrupts */
+-#define	SNDRV_PCM_HW_PARAM_PERIOD_BYTES	   14	/* Approx bytes between interrupts */
+-#define	SNDRV_PCM_HW_PARAM_PERIODS	         15	/* Approx interrupts per buffer */
+-#define	SNDRV_PCM_HW_PARAM_BUFFER_TIME	   16	/* Approx duration of buffer in us */
+-#define	SNDRV_PCM_HW_PARAM_BUFFER_SIZE	   17	/* Size of buffer in frames */
+-#define	SNDRV_PCM_HW_PARAM_BUFFER_BYTES	   18	/* Size of buffer in bytes */
+-#define	SNDRV_PCM_HW_PARAM_TICK_TIME	      19	/* Approx tick duration in us */
+-#define	SNDRV_PCM_HW_PARAM_FIRST_INTERVAL	SNDRV_PCM_HW_PARAM_SAMPLE_BITS
+-#define	SNDRV_PCM_HW_PARAM_LAST_INTERVAL	   SNDRV_PCM_HW_PARAM_TICK_TIME
+-#define SNDRV_PCM_HW_PARAMS_NORESAMPLE	      (1<<0)	/* avoid rate resampling */
+-#define SNDRV_PCM_HW_PARAMS_EXPORT_BUFFER	   (1<<1)	/* export buffer */
+-#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP	(1<<2)	/* disable period wakeups */
+-
+-#define	SNDRV_PCM_FORMAT_S8	(( tinyalsa_snd_pcm_format_t) 0)
+-#define	SNDRV_PCM_FORMAT_U8	(( tinyalsa_snd_pcm_format_t) 1)
+-#define	SNDRV_PCM_FORMAT_S16_LE	(( tinyalsa_snd_pcm_format_t) 2)
+-#define	SNDRV_PCM_FORMAT_S16_BE	(( tinyalsa_snd_pcm_format_t) 3)
+-#define	SNDRV_PCM_FORMAT_U16_LE	(( tinyalsa_snd_pcm_format_t) 4)
+-#define	SNDRV_PCM_FORMAT_U16_BE	(( tinyalsa_snd_pcm_format_t) 5)
+-#define	SNDRV_PCM_FORMAT_S24_LE	(( tinyalsa_snd_pcm_format_t) 6) /* low three bytes */
+-#define	SNDRV_PCM_FORMAT_S24_BE	(( tinyalsa_snd_pcm_format_t) 7) /* low three bytes */
+-#define	SNDRV_PCM_FORMAT_U24_LE	(( tinyalsa_snd_pcm_format_t) 8) /* low three bytes */
+-#define	SNDRV_PCM_FORMAT_U24_BE	(( tinyalsa_snd_pcm_format_t) 9) /* low three bytes */
+-#define	SNDRV_PCM_FORMAT_S32_LE	(( tinyalsa_snd_pcm_format_t) 10)
+-#define	SNDRV_PCM_FORMAT_S32_BE	(( tinyalsa_snd_pcm_format_t) 11)
+-#define	SNDRV_PCM_FORMAT_U32_LE	(( tinyalsa_snd_pcm_format_t) 12)
+-#define	SNDRV_PCM_FORMAT_U32_BE	(( tinyalsa_snd_pcm_format_t) 13)
+-#define	SNDRV_PCM_FORMAT_FLOAT_LE	(( tinyalsa_snd_pcm_format_t) 14) /* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */
+-#define	SNDRV_PCM_FORMAT_FLOAT_BE	(( tinyalsa_snd_pcm_format_t) 15) /* 4-byte float, IEEE-754 32-bit, range -1.0 to 1.0 */
+-#define	SNDRV_PCM_FORMAT_FLOAT64_LE	(( tinyalsa_snd_pcm_format_t) 16) /* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */
+-#define	SNDRV_PCM_FORMAT_FLOAT64_BE	(( tinyalsa_snd_pcm_format_t) 17) /* 8-byte float, IEEE-754 64-bit, range -1.0 to 1.0 */
+-#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE (( tinyalsa_snd_pcm_format_t) 18) /* IEC-958 subframe, Little Endian */
+-#define	SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE (( tinyalsa_snd_pcm_format_t) 19) /* IEC-958 subframe, Big Endian */
+-#define	SNDRV_PCM_FORMAT_MU_LAW		(( tinyalsa_snd_pcm_format_t) 20)
+-#define	SNDRV_PCM_FORMAT_A_LAW		(( tinyalsa_snd_pcm_format_t) 21)
+-#define	SNDRV_PCM_FORMAT_IMA_ADPCM	(( tinyalsa_snd_pcm_format_t) 22)
+-#define	SNDRV_PCM_FORMAT_MPEG		(( tinyalsa_snd_pcm_format_t) 23)
+-#define	SNDRV_PCM_FORMAT_GSM		(( tinyalsa_snd_pcm_format_t) 24)
+-#define	SNDRV_PCM_FORMAT_SPECIAL	(( tinyalsa_snd_pcm_format_t) 31)
+-#define	SNDRV_PCM_FORMAT_S24_3LE	(( tinyalsa_snd_pcm_format_t) 32)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_S24_3BE	(( tinyalsa_snd_pcm_format_t) 33)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_U24_3LE	(( tinyalsa_snd_pcm_format_t) 34)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_U24_3BE	(( tinyalsa_snd_pcm_format_t) 35)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_S20_3LE	(( tinyalsa_snd_pcm_format_t) 36)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_S20_3BE	(( tinyalsa_snd_pcm_format_t) 37)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_U20_3LE	(( tinyalsa_snd_pcm_format_t) 38)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_U20_3BE	(( tinyalsa_snd_pcm_format_t) 39)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_S18_3LE	(( tinyalsa_snd_pcm_format_t) 40)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_S18_3BE	(( tinyalsa_snd_pcm_format_t) 41)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_U18_3LE	(( tinyalsa_snd_pcm_format_t) 42)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_U18_3BE	(( tinyalsa_snd_pcm_format_t) 43)	/* in three bytes */
+-#define	SNDRV_PCM_FORMAT_G723_24	(( tinyalsa_snd_pcm_format_t) 44) /* 8 samples in 3 bytes */
+-#define	SNDRV_PCM_FORMAT_G723_24_1B	(( tinyalsa_snd_pcm_format_t) 45) /* 1 sample in 1 byte */
+-#define	SNDRV_PCM_FORMAT_G723_40	(( tinyalsa_snd_pcm_format_t) 46) /* 8 Samples in 5 bytes */
+-#define	SNDRV_PCM_FORMAT_G723_40_1B	(( tinyalsa_snd_pcm_format_t) 47) /* 1 sample in 1 byte */
+-#define	SNDRV_PCM_FORMAT_DSD_U8		(( tinyalsa_snd_pcm_format_t) 48) /* DSD, 1-byte samples DSD (x8) */
+-#define	SNDRV_PCM_FORMAT_DSD_U16_LE	(( tinyalsa_snd_pcm_format_t) 49) /* DSD, 2-byte samples DSD (x16), little endian */
+-#define	SNDRV_PCM_FORMAT_DSD_U32_LE	(( tinyalsa_snd_pcm_format_t) 50) /* DSD, 4-byte samples DSD (x32), little endian */
+-#define	SNDRV_PCM_FORMAT_DSD_U16_BE	(( tinyalsa_snd_pcm_format_t) 51) /* DSD, 2-byte samples DSD (x16), big endian */
+-#define	SNDRV_PCM_FORMAT_DSD_U32_BE	(( tinyalsa_snd_pcm_format_t) 52) /* DSD, 4-byte samples DSD (x32), big endian */
+-#define	SNDRV_PCM_FORMAT_LAST		SNDRV_PCM_FORMAT_DSD_U32_BE
+-
+-#define SNDRV_MASK_MAX	               256
+-
+-#define SNDRV_PCM_SYNC_PTR_HWSYNC	   (1<<0)	/* execute hwsync */
+-#define SNDRV_PCM_SYNC_PTR_APPL		   (1<<1)	/* get appl_ptr from driver (r/w op) */
+-#define SNDRV_PCM_SYNC_PTR_AVAIL_MIN	(1<<2)	/* get avail_min from driver */
+-
+-#define SNDRV_PCM_MMAP_OFFSET_DATA     0x00000000
+-#define SNDRV_PCM_MMAP_OFFSET_STATUS   0x80000000
+-#define SNDRV_PCM_MMAP_OFFSET_CONTROL  0x81000000
+-
+-/** Audio sample format of a PCM.
+- * The first letter specifiers whether the sample is signed or unsigned.
+- * The letter 'S' means signed. The letter 'U' means unsigned.
+- * The following number is the amount of bits that the sample occupies in memory.
+- * Following the underscore, specifiers whether the sample is big endian or little endian.
+- * The letters 'LE' mean little endian.
+- * The letters 'BE' mean big endian.
+- * This enumeration is used in the @ref pcm_config structure.
+- * @ingroup libtinyalsa-pcm
+- */
+-enum pcm_format
+-{
+-   /** Signed, 8-bit */
+-   PCM_FORMAT_S8 = 1,
+-   /** Signed 16-bit, little endian */
+-   PCM_FORMAT_S16_LE = 0,
+-   /** Signed, 16-bit, big endian */
+-   PCM_FORMAT_S16_BE = 2,
+-   /** Signed, 24-bit (32-bit in memory), little endian */
+-   PCM_FORMAT_S24_LE,
+-   /** Signed, 24-bit (32-bit in memory), big endian */
+-   PCM_FORMAT_S24_BE,
+-   /** Signed, 24-bit, little endian */
+-   PCM_FORMAT_S24_3LE,
+-   /** Signed, 24-bit, big endian */
+-   PCM_FORMAT_S24_3BE,
+-   /** Signed, 32-bit, little endian */
+-   PCM_FORMAT_S32_LE,
+-   /** Signed, 32-bit, big endian */
+-   PCM_FORMAT_S32_BE,
+-   /** Max of the enumeration list, not an actual format. */
+-   PCM_FORMAT_MAX
+-};
+-
+-enum
+-{
+-	SNDRV_PCM_TSTAMP_NONE = 0,
+-	SNDRV_PCM_TSTAMP_ENABLE,
+-	SNDRV_PCM_TSTAMP_LAST = SNDRV_PCM_TSTAMP_ENABLE
+-};
+-
+-/** Enumeration of a PCM's hardware parameters.
+- * Each of these parameters is either a mask or an interval.
+- * @ingroup libtinyalsa-pcm
+- */
+-enum pcm_param
+-{
+-   /** A mask that represents the type of read or write method available (e.g. interleaved, mmap). */
+-   PCM_PARAM_ACCESS,
+-   /** A mask that represents the @ref pcm_format available (e.g. @ref PCM_FORMAT_S32_LE) */
+-   PCM_PARAM_FORMAT,
+-   /** A mask that represents the subformat available */
+-   PCM_PARAM_SUBFORMAT,
+-   /** An interval representing the range of sample bits available (e.g. 8 to 32) */
+-   PCM_PARAM_SAMPLE_BITS,
+-   /** An interval representing the range of frame bits available (e.g. 8 to 64) */
+-   PCM_PARAM_FRAME_BITS,
+-   /** An interval representing the range of channels available (e.g. 1 to 2) */
+-   PCM_PARAM_CHANNELS,
+-   /** An interval representing the range of rates available (e.g. 44100 to 192000) */
+-   PCM_PARAM_RATE,
+-   PCM_PARAM_PERIOD_TIME,
+-   /** The number of frames in a period */
+-   PCM_PARAM_PERIOD_SIZE,
+-   /** The number of bytes in a period */
+-   PCM_PARAM_PERIOD_BYTES,
+-   /** The number of periods for a PCM */
+-   PCM_PARAM_PERIODS,
+-   PCM_PARAM_BUFFER_TIME,
+-   PCM_PARAM_BUFFER_SIZE,
+-   PCM_PARAM_BUFFER_BYTES,
+-   PCM_PARAM_TICK_TIME
+-}; /* enum pcm_param */
+-
+-/* channel positions */
+-enum
+-{
+-	SNDRV_CHMAP_UNKNOWN = 0,
+-	SNDRV_CHMAP_NA,		/* N/A, silent */
+-	SNDRV_CHMAP_MONO,	/* mono stream */
+-	/* this follows the alsa-lib mixer channel value + 3 */
+-	SNDRV_CHMAP_FL,		/* front left */
+-	SNDRV_CHMAP_FR,		/* front right */
+-	SNDRV_CHMAP_RL,		/* rear left */
+-	SNDRV_CHMAP_RR,		/* rear right */
+-	SNDRV_CHMAP_FC,		/* front center */
+-	SNDRV_CHMAP_LFE,	/* LFE */
+-	SNDRV_CHMAP_SL,		/* side left */
+-	SNDRV_CHMAP_SR,		/* side right */
+-	SNDRV_CHMAP_RC,		/* rear center */
+-	/* new definitions */
+-	SNDRV_CHMAP_FLC,	/* front left center */
+-	SNDRV_CHMAP_FRC,	/* front right center */
+-	SNDRV_CHMAP_RLC,	/* rear left center */
+-	SNDRV_CHMAP_RRC,	/* rear right center */
+-	SNDRV_CHMAP_FLW,	/* front left wide */
+-	SNDRV_CHMAP_FRW,	/* front right wide */
+-	SNDRV_CHMAP_FLH,	/* front left high */
+-	SNDRV_CHMAP_FCH,	/* front center high */
+-	SNDRV_CHMAP_FRH,	/* front right high */
+-	SNDRV_CHMAP_TC,		/* top center */
+-	SNDRV_CHMAP_TFL,	/* top front left */
+-	SNDRV_CHMAP_TFR,	/* top front right */
+-	SNDRV_CHMAP_TFC,	/* top front center */
+-	SNDRV_CHMAP_TRL,	/* top rear left */
+-	SNDRV_CHMAP_TRR,	/* top rear right */
+-	SNDRV_CHMAP_TRC,	/* top rear center */
+-	/* new definitions for UAC2 */
+-	SNDRV_CHMAP_TFLC,	/* top front left center */
+-	SNDRV_CHMAP_TFRC,	/* top front right center */
+-	SNDRV_CHMAP_TSL,	/* top side left */
+-	SNDRV_CHMAP_TSR,	/* top side right */
+-	SNDRV_CHMAP_LLFE,	/* left LFE */
+-	SNDRV_CHMAP_RLFE,	/* right LFE */
+-	SNDRV_CHMAP_BC,		/* bottom center */
+-	SNDRV_CHMAP_BLC,	/* bottom left center */
+-	SNDRV_CHMAP_BRC,	/* bottom right center */
+-	SNDRV_CHMAP_LAST = SNDRV_CHMAP_BRC
+-};
+-
+-enum
+-{
+-   SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,	/* gettimeofday equivalent */
+-   SNDRV_PCM_TSTAMP_TYPE_MONOTONIC,	         /* posix_clock_monotonic equivalent */
+-   SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,      /* monotonic_raw (no NTP) */
+-   SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW
+-};
+-
+-typedef unsigned long snd_pcm_uframes_t;
+-typedef signed long snd_pcm_sframes_t;
+-typedef int snd_pcm_hw_param_t;
+-typedef int __bitwise tinyalsa_snd_pcm_access_t;
+-typedef int __bitwise tinyalsa_snd_pcm_subformat_t;
+-typedef int __bitwise tinyalsa_snd_pcm_state_t;
+-typedef int __bitwise tinyalsa_snd_pcm_format_t;
+-
+-/** A bit mask of 256 bits (32 bytes) that describes some hardware parameters of a PCM */
+-struct pcm_mask
+-{
+-    /** bits of the bit mask */
+-    unsigned int bits[32 / sizeof(unsigned int)];
+-};
+-
+-union snd_pcm_sync_id
+-{
+-	unsigned char id[16];
+-	unsigned short id16[8];
+-	unsigned int id32[4];
+-};
+-
+-struct snd_pcm_mmap_status
+-{
+-	tinyalsa_snd_pcm_state_t state;		/* RO: state - SNDRV_PCM_STATE_XXXX */
+-	int pad1;			/* Needed for 64 bit alignment */
+-	snd_pcm_uframes_t hw_ptr;	/* RO: hw ptr (0...boundary-1) */
+-	struct timespec tstamp;		/* Timestamp */
+-	tinyalsa_snd_pcm_state_t suspended_state; /* RO: suspended stream state */
+-	struct timespec audio_tstamp;	/* from sample counter or wall clock */
+-};
+-
+-struct snd_pcm_info
+-{
+-	unsigned int device;		/* RO/WR (control): device number */
+-	unsigned int subdevice;		/* RO/WR (control): subdevice number */
+-	int stream;			/* RO/WR (control): stream direction */
+-	int card;			/* R: card number */
+-	unsigned char id[64];		/* ID (user selectable) */
+-	unsigned char name[80];		/* name of this device */
+-	unsigned char subname[32];	/* subdevice name */
+-	int dev_class;			/* SNDRV_PCM_CLASS_* */
+-	int dev_subclass;		/* SNDRV_PCM_SUBCLASS_* */
+-	unsigned int subdevices_count;
+-	unsigned int subdevices_avail;
+-	union snd_pcm_sync_id sync;	/* hardware synchronization ID */
+-	unsigned char reserved[64];	/* reserved for future... */
+-};
+-
+-struct snd_interval
+-{
+-   unsigned int min, max;
+-   unsigned int openmin:1,
+-                openmax:1,
+-                integer:1,
+-                empty:1;
+-};
+-
+-struct snd_mask
+-{
+-	__u32 bits[(SNDRV_MASK_MAX+31)/32];
+-};
+-
+-struct snd_pcm_sw_params
+-{
+-	int tstamp_mode;			/* timestamp mode */
+-	unsigned int period_step;
+-	unsigned int sleep_min;			/* min ticks to sleep */
+-	snd_pcm_uframes_t avail_min;		/* min avail frames for wakeup */
+-	snd_pcm_uframes_t xfer_align;		/* obsolete: xfer size need to be a multiple */
+-	snd_pcm_uframes_t start_threshold;	/* min hw_avail frames for automatic start */
+-	snd_pcm_uframes_t stop_threshold;	/* min avail frames for automatic stop */
+-	snd_pcm_uframes_t silence_threshold;	/* min distance from noise for silence filling */
+-	snd_pcm_uframes_t silence_size;		/* silence block size */
+-	snd_pcm_uframes_t boundary;		/* pointers wrap point */
+-	unsigned int proto;			/* protocol version */
+-	unsigned int tstamp_type;		/* timestamp type (req. proto >= 2.0.12) */
+-	unsigned char reserved[56];		/* reserved for future */
+-};
+-
+-struct snd_pcm_hw_params
+-{
+-   unsigned int flags;
+-   struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK -
+-      SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
+-   struct snd_mask mres[5];	/* reserved masks */
+-   struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
+-      SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
+-   struct snd_interval ires[9];	/* reserved intervals */
+-   unsigned int rmask;		/* W: requested masks */
+-   unsigned int cmask;		/* R: changed masks */
+-   unsigned int info;		/* R: Info flags for returned setup */
+-   unsigned int msbits;		/* R: used most significant bits */
+-   unsigned int rate_num;		/* R: rate numerator */
+-   unsigned int rate_den;		/* R: rate denominator */
+-   snd_pcm_uframes_t fifo_size;	/* R: chip FIFO size in frames */
+-   unsigned char reserved[64];	/* reserved for future */
+-};
+-
+-/** Encapsulates the hardware and software parameters of a PCM.
+- * @ingroup libtinyalsa-pcm
+- */
+-struct pcm_config
+-{
+-   /** The number of channels in a frame */
+-   unsigned int channels;
+-   /** The number of frames per second */
+-   unsigned int rate;
+-   /** The number of frames in a period */
+-   unsigned int period_size;
+-   /** The number of periods in a PCM */
+-   unsigned int period_count;
+-   /** The sample format of a PCM */
+-   enum pcm_format format;
+-   /* Values to use for the ALSA start, stop and silence thresholds.  Setting
+-    * any one of these values to 0 will cause the default tinyalsa values to be
+-    * used instead.  Tinyalsa defaults are as follows.
+-    *
+-    * start_threshold   : period_count * period_size
+-    * stop_threshold    : period_count * period_size
+-    * silence_threshold : 0
+-    */
+-   /** The minimum number of frames required to start the PCM */
+-   unsigned int start_threshold;
+-   /** The minimum number of frames required to stop the PCM */
+-   unsigned int stop_threshold;
+-   /** The minimum number of frames to silence the PCM */
+-   unsigned int silence_threshold;
+-};
+-
+-struct snd_pcm_mmap_control
+-{
+-	snd_pcm_uframes_t appl_ptr;	/* RW: appl ptr (0...boundary-1) */
+-	snd_pcm_uframes_t avail_min;	/* RW: min available frames for wakeup */
+-};
+-
+-struct snd_pcm_sync_ptr
+-{
+-   unsigned int flags;
+-   union
+-   {
+-      struct snd_pcm_mmap_status status;
+-      unsigned char reserved[64];
+-   } s;
+-   union
+-   {
+-      struct snd_pcm_mmap_control control;
+-      unsigned char reserved[64];
+-   } c;
+-};
+-
+-struct snd_xferi
+-{
+-   snd_pcm_sframes_t result;
+-   void  *buf;
+-   snd_pcm_uframes_t frames;
+-};
+-
+-struct snd_xfern
+-{
+-   snd_pcm_sframes_t result;
+-   void  *  *bufs;
+-   snd_pcm_uframes_t frames;
+-};
+-
+-struct snd_pcm_status
+-{
+-   tinyalsa_snd_pcm_state_t state;		/* stream state */
+-   struct timespec trigger_tstamp;	/* time when stream was started/stopped/paused */
+-   struct timespec tstamp;		/* reference timestamp */
+-   snd_pcm_uframes_t appl_ptr;	/* appl ptr */
+-   snd_pcm_uframes_t hw_ptr;	/* hw ptr */
+-   snd_pcm_sframes_t delay;	/* current delay in frames */
+-   snd_pcm_uframes_t avail;	/* number of frames available */
+-   snd_pcm_uframes_t avail_max;	/* max frames available on hw since last status */
+-   snd_pcm_uframes_t overrange;	/* count of ADC (capture) overrange detections from last status */
+-   tinyalsa_snd_pcm_state_t suspended_state; /* suspended stream state */
+-   __u32 reserved_alignment;	/* must be filled with zero */
+-   struct timespec audio_tstamp;	/* from sample counter or wall clock */
+-   unsigned char reserved[56-sizeof(struct timespec)]; /* must be filled with zero */
+-};
+-
+-struct pcm_params;
+-
+-#define TINYALSA_CHANNELS_MAX 32U
+-#define TINYALSA_CHANNELS_MIN 1U
+-#define TINYALSA_FRAMES_MAX (ULONG_MAX / (TINYALSA_CHANNELS_MAX * 4))
+-
+-#define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
+-#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP (1<<2)
+-
+-static INLINE int param_is_mask(int p)
+-{
+-   return (p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
+-      (p <= SNDRV_PCM_HW_PARAM_LAST_MASK);
+-}
+-
+-static INLINE int param_is_interval(int p)
+-{
+-   return (p >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL) &&
+-      (p <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL);
+-}
+-
+-static INLINE const struct snd_interval *param_get_interval(const struct snd_pcm_hw_params *p, int n)
+-{
+-   return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
+-}
+-
+-static INLINE struct snd_interval *param_to_interval(struct snd_pcm_hw_params *p, int n)
+-{
+-    return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
+-}
+-
+-static INLINE struct snd_mask *param_to_mask(struct snd_pcm_hw_params *p, int n)
+-{
+-    return &(p->masks[n - SNDRV_PCM_HW_PARAM_FIRST_MASK]);
+-}
+-
+-static void param_set_mask(struct snd_pcm_hw_params *p, int n, unsigned int bit)
+-{
+-    if (bit >= SNDRV_MASK_MAX)
+-        return;
+-    if (param_is_mask(n))
+-    {
+-        struct snd_mask *m = param_to_mask(p, n);
+-        m->bits[0] = 0;
+-        m->bits[1] = 0;
+-        m->bits[bit >> 5] |= (1 << (bit & 31));
+-    }
+-}
+-
+-static void param_set_min(struct snd_pcm_hw_params *p, int n, unsigned int val)
+-{
+-    if (param_is_interval(n))
+-    {
+-        struct snd_interval *i = param_to_interval(p, n);
+-        i->min = val;
+-    }
+-}
+-
+-static void param_set_int(struct snd_pcm_hw_params *p, int n, unsigned int val)
+-{
+-    if (param_is_interval(n))
+-    {
+-        struct snd_interval *i = param_to_interval(p, n);
+-        i->min = val;
+-        i->max = val;
+-        i->integer = 1;
+-    }
+-}
+-
+-static unsigned int param_get_int(struct snd_pcm_hw_params *p, int n)
+-{
+-    if (param_is_interval(n))
+-    {
+-        struct snd_interval *i = param_to_interval(p, n);
+-        if (i->integer)
+-            return i->max;
+-    }
+-    return 0;
+-}
+-
+-static void param_init(struct snd_pcm_hw_params *p)
+-{
+-   int n;
+-
+-   memset(p, 0, sizeof(*p));
+-   for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+-         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++)
+-   {
+-      struct snd_mask *m = param_to_mask(p, n);
+-      m->bits[0] = ~0;
+-      m->bits[1] = ~0;
+-   }
+-   for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+-         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++)
+-   {
+-      struct snd_interval *i = param_to_interval(p, n);
+-      i->min = 0;
+-      i->max = ~0;
+-   }
+-   p->rmask = ~0U;
+-   p->cmask = 0;
+-   p->info = ~0U;
+-}
+-
+-static unsigned int pcm_format_to_alsa(enum pcm_format format)
+-{
+-   switch (format)
+-   {
+-      case PCM_FORMAT_S8:
+-         return SNDRV_PCM_FORMAT_S8;
+-
+-      default:
+-      case PCM_FORMAT_S16_LE:
+-         return SNDRV_PCM_FORMAT_S16_LE;
+-      case PCM_FORMAT_S16_BE:
+-         return SNDRV_PCM_FORMAT_S16_BE;
+-
+-      case PCM_FORMAT_S24_LE:
+-         return SNDRV_PCM_FORMAT_S24_LE;
+-      case PCM_FORMAT_S24_BE:
+-         return SNDRV_PCM_FORMAT_S24_BE;
+-
+-      case PCM_FORMAT_S24_3LE:
+-         return SNDRV_PCM_FORMAT_S24_3LE;
+-      case PCM_FORMAT_S24_3BE:
+-         return SNDRV_PCM_FORMAT_S24_3BE;
+-
+-      case PCM_FORMAT_S32_LE:
+-         return SNDRV_PCM_FORMAT_S32_LE;
+-      case PCM_FORMAT_S32_BE:
+-         return SNDRV_PCM_FORMAT_S32_BE;
+-   }
+-}
+-
+-#define PCM_ERROR_MAX 128
+-
+-/** A PCM handle.
+- * @ingroup libtinyalsa-pcm
+- */
+-struct pcm
+-{
+-   /** The PCM's file descriptor */
+-   int fd;
+-   /** Flags that were passed to @ref pcm_open */
+-   unsigned int flags;
+-   /** Whether the PCM is running or not */
+-   unsigned int running:1;
+-   /** Whether or not the PCM has been prepared */
+-   unsigned int prepared:1;
+-   /** The number of underruns that have occured */
+-   int underruns;
+-   /** Size of the buffer */
+-   unsigned int buffer_size;
+-   /** The boundary for ring buffer pointers */
+-   unsigned int boundary;
+-   /** Description of the last error that occured */
+-   char error[PCM_ERROR_MAX];
+-   /** Configuration that was passed to @ref pcm_open */
+-   struct pcm_config config;
+-   struct snd_pcm_mmap_status *mmap_status;
+-   struct snd_pcm_mmap_control *mmap_control;
+-   struct snd_pcm_sync_ptr *sync_ptr;
+-   void *mmap_buffer;
+-   unsigned int noirq_frames_per_msec;
+-   /** The delay of the PCM, in terms of frames */
+-   long pcm_delay;
+-   /** The subdevice corresponding to the PCM */
+-   unsigned int subdevice;
+-};
+-
+-/** Gets the buffer size of the PCM.
+- * @param pcm A PCM handle.
+- * @return The buffer size of the PCM.
+- * @ingroup libtinyalsa-pcm
+- */
+-static unsigned int pcm_get_buffer_size(const struct pcm *pcm)
+-{
+-   return pcm->buffer_size;
+-}
+-
+-#if 0
+-/* Unused for now */
+-
+-/** Gets the channel count of the PCM.
+- * @param pcm A PCM handle.
+- * @return The channel count of the PCM.
+- * @ingroup libtinyalsa-pcm
+- */
+-static unsigned int pcm_get_channels(const struct pcm *pcm)
+-{
+-   return pcm->config.channels;
+-}
+-
+-/** Gets the PCM configuration.
+- * @param pcm A PCM handle.
+- * @return The PCM configuration.
+- *  This function only returns NULL if
+- *  @p pcm is NULL.
+- * @ingroup libtinyalsa-pcm
+- * */
+-static const struct pcm_config * pcm_get_config(const struct pcm *pcm)
+-{
+-   if (!pcm)
+-      return NULL;
+-   return &pcm->config;
+-}
+-
+-/** Gets the rate of the PCM.
+- * The rate is given in frames per second.
+- * @param pcm A PCM handle.
+- * @return The rate of the PCM.
+- * @ingroup libtinyalsa-pcm
+- */
+-static unsigned int pcm_get_rate(const struct pcm *pcm)
+-{
+-   return pcm->config.rate;
+-}
+-
+-/** Gets the format of the PCM.
+- * @param pcm A PCM handle.
+- * @return The format of the PCM.
+- * @ingroup libtinyalsa-pcm
+- */
+-static enum pcm_format pcm_get_format(const struct pcm *pcm)
+-{
+-   return pcm->config.format;
+-}
+-
+-/** Gets the file descriptor of the PCM.
+- * Useful for extending functionality of the PCM when needed.
+- * @param pcm A PCM handle.
+- * @return The file descriptor of the PCM.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_get_file_descriptor(const struct pcm *pcm)
+-{
+-   return pcm->fd;
+-}
+-
+-/** Gets the error message for the last error that occured.
+- * If no error occured and this function is called, the results are undefined.
+- * @param pcm A PCM handle.
+- * @return The error message of the last error that occured.
+- * @ingroup libtinyalsa-pcm
+- */
+-static const char* pcm_get_error(const struct pcm *pcm)
+-{
+-   return pcm->error;
+-}
+-
+-/** Gets the subdevice on which the pcm has been opened.
+- * @param pcm A PCM handle.
+- * @return The subdevice on which the pcm has been opened */
+-static unsigned int pcm_get_subdevice(const struct pcm *pcm)
+-{
+-    return pcm->subdevice;
+-}
+-
+-/** Determines how many frames of a PCM can fit into a number of bytes.
+- * @param pcm A PCM handle.
+- * @param bytes The number of bytes.
+- * @return The number of frames that may fit into @p bytes
+- * @ingroup libtinyalsa-pcm
+- */
+-static unsigned int pcm_bytes_to_frames(const struct pcm *pcm, unsigned int bytes)
+-{
+-    return bytes / (pcm->config.channels *
+-        (pcm_format_to_bits(pcm->config.format) >> 3));
+-}
+-#endif
+-
+-/** Determines the number of bits occupied by a @ref pcm_format.
+- * @param format A PCM format.
+- * @return The number of bits associated with @p format
+- * @ingroup libtinyalsa-pcm
+- */
+-unsigned int pcm_format_to_bits(enum pcm_format format)
+-{
+-   switch (format)
+-   {
+-      case PCM_FORMAT_S32_LE:
+-      case PCM_FORMAT_S32_BE:
+-      case PCM_FORMAT_S24_LE:
+-      case PCM_FORMAT_S24_BE:
+-         return 32;
+-      case PCM_FORMAT_S24_3LE:
+-      case PCM_FORMAT_S24_3BE:
+-         return 24;
+-      default:
+-      case PCM_FORMAT_S16_LE:
+-      case PCM_FORMAT_S16_BE:
+-         return 16;
+-      case PCM_FORMAT_S8:
+-         return 8;
+-   }
+-}
+-
+-/** Determines how many bytes are occupied by a number of frames of a PCM.
+- * @param pcm A PCM handle.
+- * @param frames The number of frames of a PCM.
+- * @return The bytes occupied by @p frames.
+- * @ingroup libtinyalsa-pcm
+- */
+-static unsigned int pcm_frames_to_bytes(const struct pcm *pcm, unsigned int frames)
+-{
+-   return frames * pcm->config.channels *
+-      (pcm_format_to_bits(pcm->config.format) >> 3);
+-}
+-
+-/** Sets the PCM configuration.
+- * @param pcm A PCM handle.
+- * @param config The configuration to use for the
+- *  PCM. This parameter may be NULL, in which case
+- *  the default configuration is used.
+- * @returns Zero on success, a negative errno value
+- *  on failure.
+- * @ingroup libtinyalsa-pcm
+- * */
+-static int pcm_set_config(struct pcm *pcm, const struct pcm_config *config)
+-{
+-    struct snd_pcm_sw_params sparams;
+-    struct snd_pcm_hw_params params;
+-
+-    if (!pcm)
+-        return -EFAULT;
+-
+-    if (config)
+-        pcm->config = *config;
+-    else
+-    {
+-        config = &pcm->config;
+-        pcm->config.channels = 2;
+-        pcm->config.rate = 48000;
+-        pcm->config.period_size = 1024;
+-        pcm->config.period_count = 4;
+-        pcm->config.format = PCM_FORMAT_S16_LE;
+-        pcm->config.start_threshold = config->period_count * config->period_size;
+-        pcm->config.stop_threshold = config->period_count * config->period_size;
+-        pcm->config.silence_threshold = 0;
+-    }
+-
+-    param_init(&params);
+-    param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+-                   pcm_format_to_alsa(config->format));
+-    param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+-                   SNDRV_PCM_SUBFORMAT_STD);
+-    param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, config->period_size);
+-    param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+-                  pcm_format_to_bits(config->format));
+-    param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+-                  pcm_format_to_bits(config->format) * config->channels);
+-    param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+-                  config->channels);
+-    param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
+-    param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
+-
+-    if (pcm->flags & PCM_NOIRQ)
+-    {
+-        if (!(pcm->flags & PCM_MMAP))
+-        {
+-            RARCH_ERR("[TINYALSA]: noirq only currently supported with mmap().");
+-            return -EINVAL;
+-        }
+-
+-        params.flags |= SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP;
+-        pcm->noirq_frames_per_msec = config->rate / 1000;
+-    }
+-
+-    if (pcm->flags & PCM_MMAP)
+-        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+-                   SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
+-    else
+-        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+-                   SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+-
+-    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params))
+-    {
+-        RARCH_ERR("[TINYALSA]: cannot set HW params.");
+-        return -errno;
+-    }
+-
+-    /* get our refined hw_params */
+-    pcm->config.period_size = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+-    pcm->config.period_count = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIODS);
+-    pcm->buffer_size = config->period_count * config->period_size;
+-
+-    if (pcm->flags & PCM_MMAP)
+-    {
+-        pcm->mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm->buffer_size),
+-                                PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm->fd, 0);
+-        if (pcm->mmap_buffer == MAP_FAILED)
+-        {
+-            RARCH_ERR("[TINYALSA]: failed to mmap buffer %d bytes\n",
+-                 pcm_frames_to_bytes(pcm, pcm->buffer_size));
+-            return -errno;
+-        }
+-    }
+-
+-    memset(&sparams, 0, sizeof(sparams));
+-    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_ENABLE;
+-    sparams.period_step = 1;
+-    sparams.avail_min   = 1;
+-
+-    if (!config->start_threshold)
+-    {
+-        if (pcm->flags & PCM_IN)
+-            pcm->config.start_threshold = sparams.start_threshold = 1;
+-        else
+-            pcm->config.start_threshold = sparams.start_threshold =
+-                config->period_count * config->period_size / 2;
+-    } else
+-        sparams.start_threshold = config->start_threshold;
+-
+-    /* pick a high stop threshold - todo: does this need further tuning */
+-    if (!config->stop_threshold)
+-    {
+-        if (pcm->flags & PCM_IN)
+-            pcm->config.stop_threshold = sparams.stop_threshold =
+-                config->period_count * config->period_size * 10;
+-        else
+-            pcm->config.stop_threshold = sparams.stop_threshold =
+-                config->period_count * config->period_size;
+-    }
+-    else
+-        sparams.stop_threshold = config->stop_threshold;
+-
+-    sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
+-    sparams.silence_size = 0;
+-    sparams.silence_threshold = config->silence_threshold;
+-    pcm->boundary = sparams.boundary = pcm->buffer_size;
+-
+-    while (pcm->boundary * 2 <= INT_MAX - pcm->buffer_size)
+-        pcm->boundary *= 2;
+-
+-    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams))
+-    {
+-        RARCH_ERR("[TINYALSA]: Cannot set HW params.\n");
+-        return -errno;
+-    }
+-
+-    return 0;
+-}
+-
+-static int pcm_sync_ptr(struct pcm *pcm, int flags)
+-{
+-   if (pcm->sync_ptr)
+-   {
+-      pcm->sync_ptr->flags = flags;
+-      if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SYNC_PTR, pcm->sync_ptr) >= 0)
+-         return 0;
+-   }
+-   return -1;
+-}
+-
+-static int pcm_hw_mmap_status(struct pcm *pcm)
+-{
+-   int page_size;
+-   if (pcm->sync_ptr)
+-      return 0;
+-
+-   page_size = sysconf(_SC_PAGE_SIZE);
+-
+-   pcm->mmap_status = (struct snd_pcm_mmap_status*)
+-      mmap(NULL, page_size, PROT_READ, MAP_FILE | MAP_SHARED,
+-            pcm->fd, SNDRV_PCM_MMAP_OFFSET_STATUS);
+-   if (pcm->mmap_status == MAP_FAILED)
+-      pcm->mmap_status = NULL;
+-   if (!pcm->mmap_status)
+-      goto mmap_error;
+-
+-   pcm->mmap_control = (struct snd_pcm_mmap_control*)
+-      mmap(NULL, (size_t)page_size, PROT_READ | PROT_WRITE,
+-            MAP_FILE | MAP_SHARED, pcm->fd, SNDRV_PCM_MMAP_OFFSET_CONTROL);
+-   if (pcm->mmap_control == MAP_FAILED)
+-      pcm->mmap_control = NULL;
+-   if (!pcm->mmap_control)
+-   {
+-      munmap(pcm->mmap_status, page_size);
+-      pcm->mmap_status = NULL;
+-      goto mmap_error;
+-   }
+-   pcm->mmap_control->avail_min = 1;
+-
+-   return 0;
+-
+-mmap_error:
+-
+-   pcm->sync_ptr = (struct snd_pcm_sync_ptr*)
+-      calloc(1, sizeof(*pcm->sync_ptr));
+-   if (!pcm->sync_ptr)
+-      return -ENOMEM;
+-   pcm->mmap_status = &pcm->sync_ptr->s.status;
+-   pcm->mmap_control = &pcm->sync_ptr->c.control;
+-   pcm->mmap_control->avail_min = 1;
+-   pcm_sync_ptr(pcm, 0);
+-
+-   return 0;
+-}
+-
+-static void pcm_hw_munmap_status(struct pcm *pcm)
+-{
+-    if (pcm->sync_ptr)
+-    {
+-        free(pcm->sync_ptr);
+-        pcm->sync_ptr = NULL;
+-    }
+-    else
+-    {
+-        int page_size = sysconf(_SC_PAGE_SIZE);
+-        if (pcm->mmap_status)
+-            munmap(pcm->mmap_status, page_size);
+-        if (pcm->mmap_control)
+-            munmap(pcm->mmap_control, page_size);
+-    }
+-    pcm->mmap_status = NULL;
+-    pcm->mmap_control = NULL;
+-}
+-
+-#if 0
+-/* Unused for now */
+-
+-static int pcm_areas_copy(struct pcm *pcm, unsigned int pcm_offset,
+-                          char *buf, unsigned int src_offset,
+-                          unsigned int frames)
+-{
+-    int size_bytes = pcm_frames_to_bytes(pcm, frames);
+-    int pcm_offset_bytes = pcm_frames_to_bytes(pcm, pcm_offset);
+-    int src_offset_bytes = pcm_frames_to_bytes(pcm, src_offset);
+-
+-    /* interleaved only atm */
+-    if (pcm->flags & PCM_IN)
+-        memcpy(buf + src_offset_bytes,
+-               (char*)pcm->mmap_buffer + pcm_offset_bytes,
+-               size_bytes);
+-    else
+-        memcpy((char*)pcm->mmap_buffer + pcm_offset_bytes,
+-               buf + src_offset_bytes,
+-               size_bytes);
+-    return 0;
+-}
+-#endif
+-
+-static INLINE int pcm_mmap_capture_avail(struct pcm *pcm)
+-{
+-    int avail = pcm->mmap_status->hw_ptr - pcm->mmap_control->appl_ptr;
+-    if (avail < 0)
+-        avail += pcm->boundary;
+-    return avail;
+-}
+-
+-static INLINE int pcm_mmap_playback_avail(struct pcm *pcm)
+-{
+-    int avail = pcm->mmap_status->hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
+-
+-    if (avail < 0)
+-        avail += pcm->boundary;
+-    else if (avail >= (int)pcm->boundary)
+-        avail -= pcm->boundary;
+-
+-    return avail;
+-}
+-
+-static INLINE int pcm_mmap_avail(struct pcm *pcm)
+-{
+-    pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_HWSYNC);
+-    if (pcm->flags & PCM_IN)
+-        return pcm_mmap_capture_avail(pcm);
+-    return pcm_mmap_playback_avail(pcm);
+-}
+-
+-#if 0
+-/* Unused for now */
+-
+-static int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
+-      unsigned int *frames)
+-{
+-   unsigned int continuous, copy_frames, avail;
+-
+-   /* return the mmap buffer */
+-   *areas = pcm->mmap_buffer;
+-
+-   /* and the application offset in frames */
+-   *offset = pcm->mmap_control->appl_ptr % pcm->buffer_size;
+-
+-   avail = pcm_mmap_avail(pcm);
+-   if (avail > pcm->buffer_size)
+-      avail = pcm->buffer_size;
+-   continuous = pcm->buffer_size - *offset;
+-
+-   /* we can only copy frames if the are availabale and continuos */
+-   copy_frames = *frames;
+-   if (copy_frames > avail)
+-      copy_frames = avail;
+-   if (copy_frames > continuous)
+-      copy_frames = continuous;
+-   *frames = copy_frames;
+-
+-   return 0;
+-}
+-
+-static int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames)
+-{
+-   int ret;
+-
+-   /* not used */
+-   (void) offset;
+-
+-   /* update the application pointer in userspace and kernel */
+-   pcm_mmap_appl_forward(pcm, frames);
+-   ret = pcm_sync_ptr(pcm, 0);
+-   if (ret != 0)
+-      return ret;
+-
+-   return frames;
+-}
+-
+-static void pcm_mmap_appl_forward(struct pcm *pcm, int frames)
+-{
+-    unsigned int appl_ptr = pcm->mmap_control->appl_ptr;
+-    appl_ptr += frames;
+-
+-    /* check for boundary wrap */
+-    if (appl_ptr > pcm->boundary)
+-         appl_ptr -= pcm->boundary;
+-    pcm->mmap_control->appl_ptr = appl_ptr;
+-}
+-
+-/** Returns available frames in pcm buffer and corresponding time stamp.
+- * The clock is CLOCK_MONOTONIC if flag @ref PCM_MONOTONIC was specified in @ref pcm_open,
+- * otherwise the clock is CLOCK_REALTIME.
+- * For an input stream, frames available are frames ready for the application to read.
+- * For an output stream, frames available are the number of empty frames available for the application to write.
+- * Only available for PCMs opened with the @ref PCM_MMAP flag.
+- * @param pcm A PCM handle.
+- * @param avail The number of available frames
+- * @param tstamp The timestamp
+- * @return On success, zero is returned; on failure, negative one.
+- */
+-static int pcm_get_htimestamp(struct pcm *pcm, unsigned int *avail,
+-      struct timespec *tstamp)
+-{
+-   int frames;
+-   int rc;
+-   snd_pcm_uframes_t hw_ptr;
+-
+-   if (!pcm_is_ready(pcm))
+-      return -1;
+-
+-   rc = pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_APPL|SNDRV_PCM_SYNC_PTR_HWSYNC);
+-   if (rc < 0)
+-      return -1;
+-
+-   if ((pcm->mmap_status->state != PCM_STATE_RUNNING) &&
+-         (pcm->mmap_status->state != PCM_STATE_DRAINING))
+-      return -1;
+-
+-   *tstamp = pcm->mmap_status->tstamp;
+-   if (tstamp->tv_sec == 0 && tstamp->tv_nsec == 0)
+-      return -1;
+-
+-   hw_ptr = pcm->mmap_status->hw_ptr;
+-   if (pcm->flags & PCM_IN)
+-      frames = hw_ptr - pcm->mmap_control->appl_ptr;
+-   else
+-      frames = hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
+-
+-   if (frames < 0)
+-      return -1;
+-
+-   *avail = (unsigned int)frames;
+-
+-   return 0;
+-}
+-#endif
+-
+-/** Checks if a PCM file has been opened without error.
+- * @param pcm A PCM handle.
+- *  May be NULL.
+- * @return If a PCM's file descriptor is not valid or the pointer is NULL, it returns zero.
+- *  Otherwise, the function returns one.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_is_ready(const struct pcm *pcm)
+-{
+-   if (pcm)
+-      return pcm->fd >= 0;
+-   return 0;
+-}
+-
+-/** Prepares a PCM, if it has not been prepared already.
+- * @param pcm A PCM handle.
+- * @return On success, zero; on failure, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_prepare(struct pcm *pcm)
+-{
+-   if (pcm->prepared)
+-      return 0;
+-
+-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE) < 0)
+-   {
+-      RARCH_ERR("[TINYALSA]: Cannot prepare channel.\n");
+-      return -1;
+-   }
+-
+-   pcm->prepared = 1;
+-   return 0;
+-}
+-
+-/** Writes audio samples to PCM.
+- * If the PCM has not been started, it is started in this function.
+- * This function is only valid for PCMs opened with the @ref PCM_OUT flag.
+- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
+- * @param pcm A PCM handle.
+- * @param data The audio sample array
+- * @param frame_count The number of frames occupied by the sample array.
+- *  This value should not be greater than @ref TINYALSA_FRAMES_MAX
+- *  or INT_MAX.
+- * @return On success, this function returns the number of frames written; otherwise, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_writei(struct pcm *pcm, const void *data, unsigned int frame_count)
+-{
+-   struct snd_xferi x;
+-
+-   if (pcm->flags & PCM_IN)
+-      return -EINVAL;
+-#if UINT_MAX > TINYALSA_FRAMES_MAX
+-   if (frame_count > TINYALSA_FRAMES_MAX)
+-      return -EINVAL;
+-#endif
+-   if (frame_count > INT_MAX)
+-      return -EINVAL;
+-
+-   x.buf    = (void*)data;
+-   x.frames = frame_count;
+-   x.result = 0;
+-
+-restart:
+-   if (!pcm->running)
+-   {
+-      int prepare_error = pcm_prepare(pcm);
+-      if (prepare_error)
+-         return prepare_error;
+-      if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
+-      {
+-         RARCH_ERR("[TINYALSA]: Cannot write initial data.\n");
+-         return -1;
+-      }
+-      pcm->running = 1;
+-      return 0;
+-   }
+-
+-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
+-   {
+-      pcm->prepared = 0;
+-      pcm->running = 0;
+-      if (errno == EPIPE)
+-      {
+-         /* we failed to make our window -- try to restart if we are
+-          * allowed to do so.  Otherwise, simply allow the EPIPE error to
+-          * propagate up to the app level */
+-         pcm->underruns++;
+-         if (pcm->flags & PCM_NORESTART)
+-            return -EPIPE;
+-         goto restart;
+-      }
+-#if 0
+-      /* This tends to spam a lot */
+-      RARCH_ERR("[TINYALSA]: Cannot write stream data.\n");
+-#endif
+-      return -1;
+-   }
+-
+-   return x.result;
+-}
+-
+-#if 0
+-/* Unused for now */
+-/** Starts a PCM.
+- * If the PCM has not been prepared,
+- * it is prepared in this function.
+- * @param pcm A PCM handle.
+- * @return On success, zero; on failure, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_start(struct pcm *pcm)
+-{
+-   int prepare_error = pcm_prepare(pcm);
+-   if (prepare_error)
+-      return prepare_error;
+-
+-   if (pcm->flags & PCM_MMAP)
+-      pcm_sync_ptr(pcm, 0);
+-
+-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START) < 0)
+-   {
+-      RARCH_ERR("[TINYALSA]: Cannot start channel.\n");
+-      return -1;
+-   }
+-
+-   pcm->running = 1;
+-   return 0;
+-}
+-
+-/** Reads audio samples from PCM.
+- * If the PCM has not been started, it is started in this function.
+- * This function is only valid for PCMs opened with the @ref PCM_IN flag.
+- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
+- * @param pcm A PCM handle.
+- * @param data The audio sample array
+- * @param frame_count The number of frames occupied by the sample array.
+- *  This value should not be greater than @ref TINYALSA_FRAMES_MAX
+- *  or INT_MAX.
+- * @return On success, this function returns the number of frames written; otherwise, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_readi(struct pcm *pcm, void *data, unsigned int frame_count)
+-{
+-   struct snd_xferi x;
+-
+-   if (!(pcm->flags & PCM_IN))
+-      return -EINVAL;
+-#if UINT_MAX > TINYALSA_FRAMES_MAX
+-   if (frame_count > TINYALSA_FRAMES_MAX)
+-      return -EINVAL;
+-#endif
+-   if (frame_count > INT_MAX)
+-      return -EINVAL;
+-
+-   x.buf    = data;
+-   x.frames = frame_count;
+-   x.result = 0;
+-   for (;;)
+-   {
+-      if ((!pcm->running) && (pcm_start(pcm) < 0))
+-         return -errno;
+-      else if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_READI_FRAMES, &x))
+-      {
+-         pcm->prepared = 0;
+-         pcm->running  = 0;
+-         if (errno == EPIPE)
+-         {
+-            /* we failed to make our window -- try to restart */
+-            pcm->underruns++;
+-            continue;
+-         }
+-         RARCH_ERR("[TINYALSA]: Cannot read stream data.\n");
+-         return -1;
+-      }
+-      return x.result;
+-   }
+-}
+-
+-/** Writes audio samples to PCM.
+- * If the PCM has not been started, it is started in this function.
+- * This function is only valid for PCMs opened with the @ref PCM_OUT flag.
+- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
+- * @param pcm A PCM handle.
+- * @param data The audio sample array
+- * @param count The number of bytes occupied by the sample array.
+- * @return On success, this function returns zero; otherwise, a negative number.
+- * @deprecated
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_write(struct pcm *pcm, const void *data, unsigned int count)
+-{
+-   return pcm_writei(pcm, data, pcm_bytes_to_frames(pcm, count));
+-}
+-
+-/** Reads audio samples from PCM.
+- * If the PCM has not been started, it is started in this function.
+- * This function is only valid for PCMs opened with the @ref PCM_IN flag.
+- * This function is not valid for PCMs opened with the @ref PCM_MMAP flag.
+- * @param pcm A PCM handle.
+- * @param data The audio sample array
+- * @param count The number of bytes occupied by the sample array.
+- * @return On success, this function returns zero; otherwise, a negative number.
+- * @deprecated
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_read(struct pcm *pcm, void *data, unsigned int count)
+-{
+-   return pcm_readi(pcm, data, pcm_bytes_to_frames(pcm, count));
+-}
+-#endif
+-
+-static struct pcm bad_pcm = {
+-    -1                       /* fd */
+-};
+-
+-/** Gets the hardware parameters of a PCM, without created a PCM handle.
+- * @param card The card of the PCM.
+- *  The default card is zero.
+- * @param device The device of the PCM.
+- *  The default device is zero.
+- * @param flags Specifies whether the PCM is an input or output.
+- *  May be one of the following:
+- *   - @ref PCM_IN
+- *   - @ref PCM_OUT
+- * @return On success, the hardware parameters of the PCM; on failure, NULL.
+- * @ingroup libtinyalsa-pcm
+- */
+-static struct pcm_params *pcm_params_get(unsigned int card, unsigned int device,
+-      unsigned int flags)
+-{
+-   struct snd_pcm_hw_params *params;
+-   char fn[256];
+-   int fd;
+-
+-   snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+-         flags & PCM_IN ? 'c' : 'p');
+-
+-   fd = open(fn, O_RDWR|O_NONBLOCK);
+-   if (fd < 0)
+-   {
+-      RARCH_ERR("[TINYALSA] Cannot open device '%s'\n", fn);
+-      goto err_open;
+-   }
+-
+-   params = (struct snd_pcm_hw_params*)
+-      calloc(1, sizeof(struct snd_pcm_hw_params));
+-
+-   if (!params)
+-      goto err_calloc;
+-
+-   param_init(params);
+-   if (ioctl(fd, SNDRV_PCM_IOCTL_HW_REFINE, params))
+-   {
+-      RARCH_ERR("[TINYALSA] SNDRV_PCM_IOCTL_HW_REFINE error (%d)\n", errno);
+-      goto err_hw_refine;
+-   }
+-
+-   close(fd);
+-
+-   return (struct pcm_params *)params;
+-
+-err_hw_refine:
+-   free(params);
+-err_calloc:
+-   close(fd);
+-err_open:
+-   return NULL;
+-}
+-
+-/** Frees the hardware parameters returned by @ref pcm_params_get.
+- * @param pcm_params Hardware parameters of a PCM.
+- *  May be NULL.
+- * @ingroup libtinyalsa-pcm
+- */
+-static void pcm_params_free(struct pcm_params *pcm_params)
+-{
+-   struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+-
+-   if (params)
+-      free(params);
+-}
+-
+-#if 0
+-/* Unused for now */
+-
+-/** Gets a mask from a PCM's hardware parameters.
+- * @param pcm_params A PCM's hardware parameters.
+- * @param param The parameter to get.
+- * @return If @p pcm_params is NULL or @p param is not a mask, NULL is returned.
+- *  Otherwise, the mask associated with @p param is returned.
+- * @ingroup libtinyalsa-pcm
+- */
+-static const struct pcm_mask *pcm_params_get_mask(const struct pcm_params *pcm_params,
+-      enum pcm_param param)
+-{
+-    int p;
+-    struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+-    if (!params)
+-        return NULL;
+-
+-    p = pcm_param_to_alsa(param);
+-    if (p < 0 || !param_is_mask(p))
+-        return NULL;
+-
+-    return (const struct pcm_mask *)param_to_mask(params, p);
+-}
+-#endif
+-
+-static int pcm_param_to_alsa(enum pcm_param param)
+-{
+-   switch (param)
+-   {
+-      case PCM_PARAM_ACCESS:
+-         return SNDRV_PCM_HW_PARAM_ACCESS;
+-      case PCM_PARAM_FORMAT:
+-         return SNDRV_PCM_HW_PARAM_FORMAT;
+-      case PCM_PARAM_SUBFORMAT:
+-         return SNDRV_PCM_HW_PARAM_SUBFORMAT;
+-      case PCM_PARAM_SAMPLE_BITS:
+-         return SNDRV_PCM_HW_PARAM_SAMPLE_BITS;
+-      case PCM_PARAM_FRAME_BITS:
+-         return SNDRV_PCM_HW_PARAM_FRAME_BITS;
+-      case PCM_PARAM_CHANNELS:
+-         return SNDRV_PCM_HW_PARAM_CHANNELS;
+-      case PCM_PARAM_RATE:
+-         return SNDRV_PCM_HW_PARAM_RATE;
+-      case PCM_PARAM_PERIOD_TIME:
+-         return SNDRV_PCM_HW_PARAM_PERIOD_TIME;
+-      case PCM_PARAM_PERIOD_SIZE:
+-         return SNDRV_PCM_HW_PARAM_PERIOD_SIZE;
+-      case PCM_PARAM_PERIOD_BYTES:
+-         return SNDRV_PCM_HW_PARAM_PERIOD_BYTES;
+-      case PCM_PARAM_PERIODS:
+-         return SNDRV_PCM_HW_PARAM_PERIODS;
+-      case PCM_PARAM_BUFFER_TIME:
+-         return SNDRV_PCM_HW_PARAM_BUFFER_TIME;
+-      case PCM_PARAM_BUFFER_SIZE:
+-         return SNDRV_PCM_HW_PARAM_BUFFER_SIZE;
+-      case PCM_PARAM_BUFFER_BYTES:
+-         return SNDRV_PCM_HW_PARAM_BUFFER_BYTES;
+-      case PCM_PARAM_TICK_TIME:
+-         return SNDRV_PCM_HW_PARAM_TICK_TIME;
+-
+-      default:
+-         break;
+-   }
+-
+-   return -1;
+-}
+-
+-static unsigned int param_get_min(const struct snd_pcm_hw_params *p, int n)
+-{
+-    if (param_is_interval(n))
+-    {
+-        const struct snd_interval *i = param_get_interval(p, n);
+-        return i->min;
+-    }
+-    return 0;
+-}
+-
+-/** Get the minimum of a specified PCM parameter.
+- * @param pcm_params A PCM parameters structure.
+- * @param param The specified parameter to get the minimum of.
+- * @returns On success, the parameter minimum.
+- *  On failure, zero.
+- */
+-static unsigned int pcm_params_get_min(const struct pcm_params *pcm_params,
+-      enum pcm_param param)
+-{
+-   struct snd_pcm_hw_params *params = (struct snd_pcm_hw_params *)pcm_params;
+-   int p;
+-
+-   if (!params)
+-      return 0;
+-
+-   p = pcm_param_to_alsa(param);
+-   if (p < 0)
+-      return 0;
+-
+-   return param_get_min(params, p);
+-}
+-
+-static unsigned int param_get_max(const struct snd_pcm_hw_params *p, int n)
+-{
+-    if (param_is_interval(n))
+-    {
+-        const struct snd_interval *i = param_get_interval(p, n);
+-        return i->max;
+-    }
+-    return 0;
+-}
+-
+-/** Get the maximum of a specified PCM parameter.
+- * @param pcm_params A PCM parameters structure.
+- * @param param The specified parameter to get the maximum of.
+- * @returns On success, the parameter maximum.
+- *  On failure, zero.
+- */
+-static unsigned int pcm_params_get_max(const struct pcm_params *pcm_params,
+-      enum pcm_param param)
+-{
+-   const struct snd_pcm_hw_params *params = (const struct snd_pcm_hw_params *)pcm_params;
+-   int p;
+-
+-   if (!params)
+-      return 0;
+-
+-   p = pcm_param_to_alsa(param);
+-   if (p < 0)
+-      return 0;
+-
+-   return param_get_max(params, p);
+-}
+-
+-/** Stops a PCM.
+- * @param pcm A PCM handle.
+- * @return On success, zero; on failure, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_stop(struct pcm *pcm)
+-{
+-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DROP) < 0)
+-   {
+-      RARCH_ERR("[TINYALSA]: Cannot stop channel.\n");
+-      return -1;
+-   }
+-
+-   pcm->prepared = 0;
+-   pcm->running = 0;
+-   return 0;
+-}
+-
+-static int pcm_params_can_pause(const struct pcm_params *pcm_params)
+-{
+-   const struct snd_pcm_hw_params *params = (const struct snd_pcm_hw_params *)pcm_params;
+-
+-   if (!params)
+-      return 0;
+-
+-   return (params->info & SNDRV_PCM_INFO_PAUSE) ? 1 : 0;
+-}
+-
+-static int pcm_pause(struct pcm *pcm, int enable)
+-{
+-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PAUSE, enable) < 0)
+-      return -1;
+-
+-   return 0;
+-}
+-
+-/** Closes a PCM returned by @ref pcm_open.
+- * @param pcm A PCM returned by @ref pcm_open.
+- *  May not be NULL.
+- * @return Always returns zero.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_close(struct pcm *pcm)
+-{
+-   if (pcm == &bad_pcm)
+-      return 0;
+-
+-   pcm_hw_munmap_status(pcm);
+-
+-   if (pcm->flags & PCM_MMAP)
+-   {
+-      pcm_stop(pcm);
+-      munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+-   }
+-
+-   if (pcm->fd >= 0)
+-      close(pcm->fd);
+-   pcm->prepared = 0;
+-   pcm->running = 0;
+-   pcm->buffer_size = 0;
+-   pcm->fd = -1;
+-   free(pcm);
+-   return 0;
+-}
+-
+-/** Opens a PCM.
+- * @param card The card that the pcm belongs to.
+- *  The default card is zero.
+- * @param device The device that the pcm belongs to.
+- *  The default device is zero.
+- * @param flags Specify characteristics and functionality about the pcm.
+- *  May be a bitwise AND of the following:
+- *   - @ref PCM_IN
+- *   - @ref PCM_OUT
+- *   - @ref PCM_MMAP
+- *   - @ref PCM_NOIRQ
+- *   - @ref PCM_MONOTONIC
+- * @param config The hardware and software parameters to open the PCM with.
+- * @returns A PCM structure.
+- *  If an error occurs allocating memory for the PCM, NULL is returned.
+- *  Otherwise, client code should check that the PCM opened properly by calling @ref pcm_is_ready.
+- *  If @ref pcm_is_ready, check @ref pcm_get_error for more information.
+- * @ingroup libtinyalsa-pcm
+- */
+-static struct pcm *pcm_open(unsigned int card, unsigned int device,
+-      unsigned int flags, const struct pcm_config *config)
+-{
+-   int rc;
+-   char fn[256];
+-   struct snd_pcm_info info;
+-   struct pcm *pcm = (struct pcm*)calloc(1, sizeof(struct pcm));
+-   if (!pcm)
+-      return &bad_pcm;
+-
+-   snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+-         flags & PCM_IN ? 'c' : 'p');
+-
+-   pcm->flags = flags;
+-   pcm->fd    = open(fn, O_RDWR|O_NONBLOCK);
+-   if (pcm->fd < 0)
+-   {
+-      RARCH_ERR("[TINYALSA]: cannot open device '%s'\n", fn);
+-      return pcm;
+-   }
+-
+-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info))
+-   {
+-      RARCH_ERR("[TINYALSA]: cannot get info.\n");
+-      goto fail_close;
+-   }
+-   pcm->subdevice = info.subdevice;
+-
+-   if (pcm_set_config(pcm, config) != 0)
+-      goto fail_close;
+-
+-   rc = pcm_hw_mmap_status(pcm);
+-   if (rc < 0)
+-   {
+-      RARCH_ERR("[TINYALSA]: mmap status failed.\n");
+-      goto fail;
+-   }
+-
+-#ifdef SNDRV_PCM_IOCTL_TTSTAMP
+-   if (pcm->flags & PCM_MONOTONIC)
+-   {
+-      int arg = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC;
+-      rc      = ioctl(pcm->fd, SNDRV_PCM_IOCTL_TTSTAMP, &arg);
+-      if (rc < 0)
+-      {
+-         RARCH_ERR("[TINYALSA]: Cannot set timestamp type.\n");
+-         goto fail;
+-      }
+-   }
+-#endif
+-
+-   pcm->underruns = 0;
+-   return pcm;
+-
+-fail:
+-   if (flags & PCM_MMAP)
+-      munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+-fail_close:
+-   close(pcm->fd);
+-   pcm->fd = -1;
+-   return pcm;
+-}
+-
+-#if 0
+-/* Unused for now */
+-
+-/** Opens a PCM by it's name.
+- * @param name The name of the PCM.
+- *  The name is given in the format: <i>hw</i>:<b>card</b>,<b>device</b>
+- * @param flags Specify characteristics and functionality about the pcm.
+- *  May be a bitwise AND of the following:
+- *   - @ref PCM_IN
+- *   - @ref PCM_OUT
+- *   - @ref PCM_MMAP
+- *   - @ref PCM_NOIRQ
+- *   - @ref PCM_MONOTONIC
+- * @param config The hardware and software parameters to open the PCM with.
+- * @returns A PCM structure.
+- *  If an error occurs allocating memory for the PCM, NULL is returned.
+- *  Otherwise, client code should check that the PCM opened properly by calling @ref pcm_is_ready.
+- *  If @ref pcm_is_ready, check @ref pcm_get_error for more information.
+- * @ingroup libtinyalsa-pcm
+- */
+-static struct pcm *pcm_open_by_name(const char *name,
+-      unsigned int flags,
+-      const struct pcm_config *config)
+-{
+-  unsigned int card, device;
+-  if ((name[0] != 'h')
+-   || (name[1] != 'w')
+-   || (name[2] != ':'))
+-    return NULL;
+-
+-  if (sscanf(&name[3], "%u,%u", &card, &device) != 2)
+-    return NULL;
+-
+-  return pcm_open(card, device, flags, config);
+-}
+-
+-/** Links two PCMs.
+- * After this function is called, the two PCMs will prepare, start and stop in sync (at the same time).
+- * If an error occurs, the error message will be written to @p pcm1.
+- * @param pcm1 A PCM handle.
+- * @param pcm2 Another PCM handle.
+- * @return On success, zero; on failure, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_link(struct pcm *pcm1, struct pcm *pcm2)
+-{
+-   int err = ioctl(pcm1->fd, SNDRV_PCM_IOCTL_LINK, pcm2->fd);
+-   if (err == -1)
+-   {
+-      RARCH_ERR("[TINYALSA]: Cannot link PCM.\n");
+-      return -1;
+-   }
+-   return 0;
+-}
+-
+-/** Unlinks a PCM.
+- * @see @ref pcm_link
+- * @param pcm A PCM handle.
+- * @return On success, zero; on failure, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_unlink(struct pcm *pcm)
+-{
+-   int err = ioctl(pcm->fd, SNDRV_PCM_IOCTL_UNLINK);
+-   if (err == -1)
+-   {
+-      RARCH_ERR("[TINYALSA]: Cannot unlink PCM.\n");
+-      return -1;
+-   }
+-   return 0;
+-}
+-#endif
+-
+-static int pcm_avail_update(struct pcm *pcm)
+-{
+-   pcm_sync_ptr(pcm, 0);
+-   return pcm_mmap_avail(pcm);
+-}
+-
+-#if 0
+-/* No longer used */
+-
+-static int pcm_state(struct pcm *pcm)
+-{
+-   int err = pcm_sync_ptr(pcm, 0);
+-   if (err < 0)
+-      return err;
+-
+-   return pcm->mmap_status->state;
+-}
+-#endif
+-
+-/** Waits for frames to be available for read or write operations.
+- * @param pcm A PCM handle.
+- * @param timeout The maximum amount of time to wait for, in terms of milliseconds.
+- * @returns If frames became available, one is returned.
+- *  If a timeout occured, zero is returned.
+- *  If an error occured, a negative number is returned.
+- * @ingroup libtinyalsa-pcm
+- */
+-static int pcm_wait(struct pcm *pcm, int timeout)
+-{
+-   struct pollfd pfd;
+-
+-   pfd.fd     = pcm->fd;
+-   pfd.events = POLLIN | POLLOUT | POLLERR | POLLNVAL;
+-
+-   do
+-   {
+-      /* let's wait for avail or timeout */
+-      int err = poll(&pfd, 1, timeout);
+-      if (err < 0)
+-         return -errno;
+-
+-      /* timeout ? */
+-      if (err == 0)
+-         return 0;
+-
+-      /* have we been interrupted ? */
+-      if (errno == -EINTR)
+-         continue;
+-
+-      /* check for any errors */
+-      if (pfd.revents & (POLLERR | POLLNVAL))
+-      {
+-         int cond = -1;
+-
+-         if (pcm->sync_ptr)
+-         {
+-            pcm->sync_ptr->flags = 0;
+-            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SYNC_PTR, pcm->sync_ptr) >= 0)
+-               cond = pcm->mmap_status->state;
+-         }
+-
+-         switch (cond)
+-         {
+-            case PCM_STATE_XRUN:
+-               return -EPIPE;
+-            case PCM_STATE_SUSPENDED:
+-               return -ESTRPIPE;
+-            case PCM_STATE_DISCONNECTED:
+-               return -ENODEV;
+-            default:
+-               break;
+-         }
+-
+-         return -EIO;
+-      }
+-      /* poll again if fd not ready for IO */
+-   } while (!(pfd.revents & (POLLIN | POLLOUT)));
+-
+-   return 1;
+-}
+-
+-#if 0
+-/* Unused for now */
+-
+-static int pcm_mmap_transfer(struct pcm *pcm, const void *buffer, unsigned int bytes)
+-{
+-   int err = 0, frames, avail;
+-   unsigned int offset = 0, count;
+-
+-   if (bytes == 0)
+-      return 0;
+-
+-   count = pcm_bytes_to_frames(pcm, bytes);
+-
+-   while (count > 0)
+-   {
+-      /* get the available space for writing new frames */
+-      avail = pcm_avail_update(pcm);
+-      if (avail < 0)
+-      {
+-         RARCH_ERR("[TINYALSA] Cannot determine available mmap frames");
+-         return err;
+-      }
+-
+-      /* start the audio if we reach the threshold */
+-      if (!pcm->running &&
+-            (pcm->buffer_size - avail) >= pcm->config.start_threshold)
+-      {
+-         if (pcm_start(pcm) < 0)
+-         {
+-            RARCH_ERR("[TINYALSA] Start error: hw 0x%x app 0x%x avail 0x%x\n",
+-                  (unsigned int)pcm->mmap_status->hw_ptr,
+-                  (unsigned int)pcm->mmap_control->appl_ptr,
+-                  avail);
+-            return -errno;
+-         }
+-      }
+-
+-      /* sleep until we have space to write new frames */
+-      if (pcm->running &&
+-            (unsigned int)avail < pcm->mmap_control->avail_min)
+-      {
+-         int time = -1;
+-
+-         if (pcm->flags & PCM_NOIRQ)
+-            time = (pcm->buffer_size - avail - pcm->mmap_control->avail_min)
+-               / pcm->noirq_frames_per_msec;
+-
+-         err = pcm_wait(pcm, time);
+-         if (err < 0)
+-         {
+-            pcm->prepared = 0;
+-            pcm->running = 0;
+-            RARCH_ERR("[TINYALSA] Wait error: hw 0x%x app 0x%x avail 0x%x\n",
+-                  (unsigned int)pcm->mmap_status->hw_ptr,
+-                  (unsigned int)pcm->mmap_control->appl_ptr,
+-                  avail);
+-            pcm->mmap_control->appl_ptr = 0;
+-            return err;
+-         }
+-         continue;
+-      }
+-
+-      frames = count;
+-      if (frames > avail)
+-         frames = avail;
+-
+-      if (!frames)
+-         break;
+-
+-      /* copy frames from buffer */
+-      frames = pcm_mmap_transfer_areas(pcm, (void *)buffer, offset, frames);
+-      if (frames < 0)
+-      {
+-         RARCH_ERR("[TINYALSA] Write error: hw 0x%x app 0x%x avail 0x%x\n",
+-               (unsigned int)pcm->mmap_status->hw_ptr,
+-               (unsigned int)pcm->mmap_control->appl_ptr,
+-               avail);
+-         return frames;
+-      }
+-
+-      offset += frames;
+-      count -= frames;
+-   }
+-
+-   return 0;
+-}
+-
+-static int pcm_mmap_write(struct pcm *pcm, const void *data, unsigned int count)
+-{
+-   if ((~pcm->flags) & (PCM_OUT | PCM_MMAP))
+-      return -ENOSYS;
+-
+-   return pcm_mmap_transfer(pcm, (void *)data, count);
+-}
+-
+-static int pcm_mmap_read(struct pcm *pcm, void *data, unsigned int count)
+-{
+-   if ((~pcm->flags) & (PCM_IN | PCM_MMAP))
+-      return -ENOSYS;
+-
+-   return pcm_mmap_transfer(pcm, data, count);
+-}
+-
+-/** Gets the delay of the PCM, in terms of frames.
+- * @param pcm A PCM handle.
+- * @returns On success, the delay of the PCM.
+- *  On failure, a negative number.
+- * @ingroup libtinyalsa-pcm
+- */
+-static long pcm_get_delay(struct pcm *pcm)
+-{
+-   if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DELAY, &pcm->pcm_delay) < 0)
+-      return -1;
+-
+-   return pcm->pcm_delay;
+-}
+-
+-static int pcm_mmap_transfer_areas(struct pcm *pcm, char *buf,
+-      unsigned int offset, unsigned int size)
+-{
+-   void *pcm_areas;
+-   int commit;
+-   unsigned int pcm_offset, frames, count = 0;
+-
+-   while (size > 0)
+-   {
+-      frames = size;
+-      pcm_mmap_begin(pcm, &pcm_areas, &pcm_offset, &frames);
+-      pcm_areas_copy(pcm, pcm_offset, buf, offset, frames);
+-      commit = pcm_mmap_commit(pcm, pcm_offset, frames);
+-      if (commit < 0)
+-      {
+-         RARCH_ERR("[TINYALSA}: failed to commit %d frames.\n", frames);
+-         return commit;
+-      }
+-
+-      offset += commit;
+-      count += commit;
+-      size -= commit;
+-   }
+-   return count;
+-}
+-#endif
+-
+-/* End of implementation tinyalsa pcm */
+-
+ typedef struct tinyalsa
+ {
+-   struct pcm        *pcm;
+-   struct pcm_params *params;
+-   size_t            buffer_size;
+-   bool              nonblock;
+-   bool              has_float;
+-   bool              can_pause;
+-   bool              is_paused;
+-   unsigned int      frame_bits;
++	unsigned int card;
++	unsigned int device;
++	struct pcm_config config;
++	struct pcm *pcm;
++	size_t buffer_size;
++	bool nonblock;
++	bool use_mmap;
+ } tinyalsa_t;
+ 
+-#define BYTES_TO_FRAMES(bytes, frame_bits)  ((bytes) * 8 / frame_bits)
+-#define FRAMES_TO_BYTES(frames, frame_bits) ((frames) * frame_bits / 8)
+-
+-static void * tinyalsa_init(const char *devicestr, unsigned rate,
+-      unsigned latency, unsigned block_frames,
+-      unsigned *new_rate)
++static void * tinyalsa_init(const char *devicestr, unsigned rate, unsigned latency, unsigned block_frames, unsigned *new_rate)
+ {
+-   unsigned int card            = 0;
+-   unsigned int device          = 0;
+-   unsigned int frames_per_ms   = 0;
+-   unsigned int orig_rate       = rate;
+-   unsigned int max_rate, min_rate, buffer_size;
+-   float initial_latency;
+-
+-   struct pcm_config         config;
+-
+-   tinyalsa_t *tinyalsa      = (tinyalsa_t*)calloc(1, sizeof(tinyalsa_t));
++	unsigned int card = 0;
++	unsigned int device = 0;
++	unsigned int frames_per_ms = 0;
++	unsigned int orig_rate = rate;
++	unsigned int max_rate, min_rate, buffer_size;
++	struct pcm_params *params;
++	float initial_latency;
+ 
+-   if (!tinyalsa)
+-      return NULL;
++	tinyalsa_t *tinyalsa = (tinyalsa_t*)calloc(1, sizeof(tinyalsa_t));
+ 
+-   if (devicestr)
+-      sscanf(devicestr, "%u,%u", &card, &device);
++	if (!tinyalsa)
++		return NULL;
+ 
+-   RARCH_LOG("[TINYALSA]: Using card: %u, device: %u.\n", card, device);
++	if (devicestr)
++		sscanf(devicestr, "%u,%u", &card, &device);
+ 
+-   tinyalsa->params = pcm_params_get(card, device, PCM_OUT);
+-   if (!tinyalsa->params)
+-   {
+-      RARCH_ERR("[TINYALSA]: params: Cannot open audio device.\n");
+-      goto error;
+-   }
++	tinyalsa->card = card;
++	tinyalsa->device = device;
++	tinyalsa->use_mmap = getenv("ALSA_FORCE_MMAP") != NULL;
+ 
+-   if (pcm_params_can_pause(tinyalsa->params))
+-      tinyalsa->can_pause = true;
++	RARCH_LOG("[TINYALSA]: Using card: %u, device: %u.\n", card, device);
+ 
+-   min_rate = pcm_params_get_min(tinyalsa->params, PCM_PARAM_RATE);
+-   max_rate = pcm_params_get_max(tinyalsa->params, PCM_PARAM_RATE);
+-
+-   if (!(rate >= min_rate && rate <= max_rate))
+-   {
+-      RARCH_WARN("[TINYALSA]: Sample rate cannot be larger than %uHz "\
+-                 "or smaller than %uHz.\n", max_rate, min_rate);
+-      RARCH_WARN("[TINYALSA]: Trying to set a valid sample rate.\n");
++	params = pcm_params_get(card, device, PCM_OUT);
++	if (!params)
++	{
++		RARCH_ERR("[TINYALSA]: params: Cannot open audio device.\n");
++		goto error;
++	}
+ 
+-      if (rate > max_rate)
+-         rate = max_rate;
+-      else if (rate < min_rate)
+-         rate = min_rate;
+-   }
++	min_rate = pcm_params_get_min(params, PCM_PARAM_RATE);
++	max_rate = pcm_params_get_max(params, PCM_PARAM_RATE);
+ 
+-   if (orig_rate != rate)
+-      *new_rate = rate;
++	if (!(rate >= min_rate && rate <= max_rate))
++	{
++		RARCH_WARN("[TINYALSA]: Sample rate cannot be larger than %uHz or smaller than %uHz.\n", max_rate, min_rate);
++		RARCH_WARN("[TINYALSA]: Trying to set a valid sample rate.\n");
+ 
+-   config.rate              = rate;
+-   config.format            = is_little_endian() ?\
+-                              PCM_FORMAT_S16_LE : PCM_FORMAT_S16_BE;
+-   config.channels          = 2;
+-   config.period_size       = 1024;
+-   config.period_count      = 4;
+-   config.start_threshold   = config.period_size;
+-   config.stop_threshold    = 0;
+-   config.silence_threshold = 0;
++		if (rate > max_rate)
++			rate = max_rate;
++		else if (rate < min_rate)
++			rate = min_rate;
++	}
+ 
+-   tinyalsa->pcm = pcm_open(card, device, PCM_OUT, &config);
++	if (orig_rate != rate)
++		*new_rate = rate;
+ 
+-   if (!tinyalsa->pcm)
+-   {
+-      RARCH_ERR("[TINYALSA]: Failed to allocate memory for pcm.\n");
+-      goto error;
+-   }
+-   else if (!pcm_is_ready(tinyalsa->pcm))
+-   {
+-      RARCH_ERR("[TINYALSA]: Cannot open audio device.\n");
+-      goto error;
+-   }
++	unsigned int period_size = 1024;
++	char * period_size_override = getenv("ALSA_DEFAULT_PERIOD_SIZE");
++	if (period_size_override != NULL)
++	{
++		period_size = (unsigned int)atoi(period_size_override);
++	}
+ 
+-   buffer_size           = pcm_get_buffer_size(tinyalsa->pcm);
+-   tinyalsa->buffer_size = pcm_frames_to_bytes(tinyalsa->pcm, buffer_size);
+-   tinyalsa->frame_bits  = pcm_format_to_bits(config.format) * 2;
++	tinyalsa->config.rate = rate;
++	tinyalsa->config.format = is_little_endian() ? PCM_FORMAT_S16_LE : PCM_FORMAT_S16_BE;
++	tinyalsa->config.channels = 2;
++	tinyalsa->config.period_size = period_size;
++	tinyalsa->config.period_count = 4;
++	tinyalsa->config.start_threshold = tinyalsa->config.period_size;
++	tinyalsa->config.stop_threshold = 0;
++	tinyalsa->config.silence_threshold = tinyalsa->config.period_size * tinyalsa->config.period_count;
++	tinyalsa->config.silence_size = 0;
++
++	tinyalsa->pcm = pcm_open(card, device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP : 0), &tinyalsa->config);
++
++	if (!tinyalsa->pcm)
++	{
++		RARCH_ERR("[TINYALSA]: Failed to allocate memory for pcm.\n");
++		goto error;
++	}
++	else if (!pcm_is_ready(tinyalsa->pcm))
++	{
++		RARCH_ERR("[TINYALSA]: Cannot open audio device.\n");
++		goto error;
++	}
+ 
+-   initial_latency       = (float)(buffer_size * 1000) / (float)(rate * 4);
+-   frames_per_ms         = buffer_size / initial_latency;
++	buffer_size = pcm_get_buffer_size(tinyalsa->pcm);
++	tinyalsa->buffer_size = pcm_frames_to_bytes(tinyalsa->pcm, buffer_size);
+ 
+-   if (latency < (unsigned int)initial_latency)
+-   {
+-      RARCH_WARN("[TINYALSA]: Cannot have a latency less than %ums. "\
+-                 "Defaulting to 64ms.\n", (unsigned int)initial_latency);
+-      latency = 64;
+-   }
++	initial_latency = (float)(buffer_size * 1000) / (float)(rate * 4);
++	frames_per_ms = buffer_size / initial_latency;
+ 
+-   latency               -= (unsigned int)initial_latency;
+-   buffer_size           += latency * frames_per_ms;
++	if (latency < (unsigned int)initial_latency)
++	{
++		RARCH_WARN("[TINYALSA]: Cannot have a latency less than %ums. Defaulting to 64ms.\n", (unsigned int)initial_latency);
++		latency = 64;
++	}
+ 
+-   tinyalsa->has_float   = false;
++	latency -= (unsigned int)initial_latency;
++	buffer_size += latency * frames_per_ms;
+ 
+-   RARCH_LOG("[TINYALSA]: Can pause: %s.\n", tinyalsa->can_pause ? "yes" : "no");
+-   RARCH_LOG("[TINYALSA]: Audio rate: %uHz.\n", config.rate);
+-   RARCH_LOG("[TINYALSA]: Buffer size: %u frames.\n", buffer_size);
+-   RARCH_LOG("[TINYALSA]: Buffer size: %u bytes.\n", (unsigned int)tinyalsa->buffer_size);
+-   RARCH_LOG("[TINYALSA]: Frame  size: %u bytes.\n", tinyalsa->frame_bits / 8);
+-   RARCH_LOG("[TINYALSA]: Latency: %ums.\n", buffer_size * 1000 / (rate * 4));
++	RARCH_LOG("[TINYALSA]: Audio rate: %uHz.\n", tinyalsa->config.rate);
++	RARCH_LOG("[TINYALSA]: Buffer size: %u frames.\n", buffer_size);
++	RARCH_LOG("[TINYALSA]: Buffer size: %u bytes.\n", (unsigned int)tinyalsa->buffer_size);
++	RARCH_LOG("[TINYALSA]: Frame size: %u bytes.\n", pcm_frames_to_bytes(tinyalsa->pcm, 1));
++	RARCH_LOG("[TINYALSA]: Latency: %ums.\n", buffer_size * 1000 / (rate * 4));
+ 
+-   pcm_params_free(tinyalsa->params);
++	pcm_params_free(params);
+ 
+-   return tinyalsa;
++	return tinyalsa;
+ 
+ error:
+-   RARCH_ERR("[TINYALSA]: Failed to initialize tinyalsa driver.\n");
++	RARCH_ERR("[TINYALSA]: Failed to initialize tinyalsa driver.\n");
+ 
+-   if (tinyalsa->params)
+-      pcm_params_free(tinyalsa->params);
++	if (params)
++		pcm_params_free(params);
+ 
+-   if (tinyalsa)
+-      free(tinyalsa);
++	if (tinyalsa)
++		free(tinyalsa);
+ 
+-   return NULL;
++	return NULL;
+ }
+ 
+-static ssize_t
+-tinyalsa_write(void *data, const void *buf_, size_t size_)
++static ssize_t tinyalsa_write(void *data, const void *buf_, size_t size_)
+ {
+-   tinyalsa_t *tinyalsa      = (tinyalsa_t*)data;
+-   const uint8_t *buf        = (const uint8_t*)buf_;
+-   snd_pcm_sframes_t written = 0;
+-   snd_pcm_sframes_t size    = BYTES_TO_FRAMES(size_, tinyalsa->frame_bits);
+-   size_t frames_size        = tinyalsa->has_float ? sizeof(float) : sizeof(int16_t);
+-
+-   if (tinyalsa->nonblock)
+-   {
+-      while (size)
+-      {
+-         snd_pcm_sframes_t frames   = pcm_writei(tinyalsa->pcm, buf, size);
+-
+-         if (frames < 0)
+-            pcm_stop(tinyalsa->pcm);
+-
+-         written += frames;
+-         buf     += (frames << 1) * frames_size;
+-         size    -= frames;
+-      }
+-   }
+-   else
+-   {
+-      while (size)
+-      {
+-         snd_pcm_sframes_t frames;
+-         pcm_wait(tinyalsa->pcm, -1);
+-
+-         frames   = pcm_writei(tinyalsa->pcm, buf, size);
+-
+-         if (frames < 0)
+-            return -1;
+-
+-         written += frames;
+-         buf     += (frames << 1) * frames_size;
+-         size    -= frames;
+-      }
+-   }
+-
+-   return written;
++	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
++	const uint8_t *buf = (const uint8_t*)buf_;
++	snd_pcm_sframes_t written = 0;
++	size_t frames_size = sizeof(int16_t);
++
++	if (tinyalsa->pcm)
++	{
++		snd_pcm_sframes_t size = pcm_bytes_to_frames(tinyalsa->pcm, size_);
++
++		while (size)
++		{
++			snd_pcm_sframes_t frames = pcm_writei(tinyalsa->pcm, buf, size);
++
++			if (frames < 0)
++			{
++				continue;
++			}
++
++			written += frames;
++			buf += (frames << 1) * frames_size;
++			size -= frames;
++		}
++	}
+ 
++	return written;
+ }
+ 
+-static bool
+-tinyalsa_stop(void *data)
++static bool tinyalsa_start(void *data, bool is_shutdown)
+ {
+ 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+ 
+-	if (tinyalsa->can_pause && !tinyalsa->is_paused)
+-   {
+-		int ret = pcm_pause(tinyalsa->pcm, 1);
+-		if (ret < 0)
+-			return false;
+-
+-		tinyalsa->is_paused = true;
++	while (tinyalsa->pcm == NULL)
++	{
++		tinyalsa->pcm = (int *)pcm_open(tinyalsa->card, tinyalsa->device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP : 0), &tinyalsa->config);
+ 	}
+ 
+-	return true;
++	return tinyalsa->pcm != NULL;
+ }
+ 
+-static bool
+-tinyalsa_alive(void *data)
++static bool tinyalsa_stop(void *data)
+ {
+ 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+ 
+-	if (tinyalsa)
+-		return !tinyalsa->is_paused;
++	if (tinyalsa->pcm != NULL)
++	{
++		pcm_close(tinyalsa->pcm);
++		tinyalsa->pcm = NULL;
++	}
+ 
+-	return false;
++	return true;
+ }
+ 
+-static bool
+-tinyalsa_start(void *data, bool is_shutdown)
++static bool tinyalsa_alive(void *data)
+ {
+ 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+ 
+-	if (tinyalsa->can_pause && tinyalsa->is_paused)
+-   {
+-		int ret = pcm_pause(tinyalsa->pcm, 0);
+-
+-		if (ret < 0)
+-      {
+-			RARCH_ERR("[TINYALSA]: Failed to unpause.\n");
+-			return false;
+-		}
+-
+-		tinyalsa->is_paused = false;
+-	}
+-
+-	return true;
++	return tinyalsa != NULL && tinyalsa->pcm != NULL;
+ }
+ 
+ static void tinyalsa_set_nonblock_state(void *data, bool state)
+ {
+ 	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
++
+ 	tinyalsa->nonblock = state;
+ }
+ 
+ static bool tinyalsa_use_float(void *data)
+ {
+-	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+-
+-	return tinyalsa->has_float;
++	return false;
+ }
+ 
+ static void tinyalsa_free(void *data)
+ {
+-   tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
++	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+ 
+-   if (tinyalsa)
+-   {
+-      if (tinyalsa->pcm)
+-         pcm_close(tinyalsa->pcm);
++	if (tinyalsa)
++	{
++		if (tinyalsa->pcm != NULL)
++		{
++			pcm_close(tinyalsa->pcm);
++			tinyalsa->pcm = NULL;
++		}
+ 
+-      tinyalsa->pcm = NULL;
+-      free(tinyalsa);
+-   }
++		free(tinyalsa);
++	}
+ }
+ 
+ static size_t tinyalsa_write_avail(void *data)
+ {
+-   tinyalsa_t *alsa        = (tinyalsa_t*)data;
+-   snd_pcm_sframes_t avail = pcm_avail_update(alsa->pcm);
++	tinyalsa_t *tinyalsa = (tinyalsa_t*)data;
+ 
+-   if (avail < 0)
+-      return alsa->buffer_size;
++	if (tinyalsa->pcm)
++	{
++		snd_pcm_sframes_t avail = pcm_avail_update(tinyalsa->pcm);
+ 
+-   return FRAMES_TO_BYTES(avail, alsa->frame_bits);
++		if (avail >= 0)
++		{
++			return pcm_frames_to_bytes(tinyalsa->pcm, avail);
++		}
++	}
++
++	return tinyalsa->buffer_size;
+ }
+ 
+ static size_t tinyalsa_buffer_size(void *data)
+@@ -2414,17 +282,17 @@ static size_t tinyalsa_buffer_size(void *data)
+ }
+ 
+ audio_driver_t audio_tinyalsa = {
+-	tinyalsa_init,               /* AUDIO_init              */
+-	tinyalsa_write,              /* AUDIO_write             */
+-	tinyalsa_stop,               /* AUDIO_stop              */
+-	tinyalsa_start,              /* AUDIO_start             */
+-	tinyalsa_alive,              /* AUDIO_alive             */
+-	tinyalsa_set_nonblock_state, /* AUDIO_set_nonblock_sate */
+-	tinyalsa_free,               /* AUDIO_free              */
+-	tinyalsa_use_float,          /* AUDIO_use_float         */
+-	"tinyalsa",                  /* "AUDIO"                 */
+-	NULL,                        /* AUDIO_device_list_new   */ /*TODO*/
+-	NULL,                        /* AUDIO_device_list_free  */ /*TODO*/
+-   tinyalsa_write_avail,        /* AUDIO_write_avail       */ /*TODO*/
+-	tinyalsa_buffer_size,        /* AUDIO_buffer_size       */ /*TODO*/
++	tinyalsa_init,					// AUDIO_init
++	tinyalsa_write,					// AUDIO_write
++	tinyalsa_stop,					// AUDIO_stop
++	tinyalsa_start,					// AUDIO_start
++	tinyalsa_alive,					// AUDIO_alive
++	tinyalsa_set_nonblock_state,	// AUDIO_set_nonblock_sate
++	tinyalsa_free,					// AUDIO_free
++	tinyalsa_use_float,				// AUDIO_use_float
++	"tinyalsa",						// "AUDIO"
++	NULL,							// AUDIO_device_list_new
++	NULL,							// AUDIO_device_list_free
++	tinyalsa_write_avail,			// AUDIO_write_avail
++	tinyalsa_buffer_size,			// AUDIO_buffer_size
+ };
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0003-Add-hotkey-tap-controller-combo.patch b/oldpatches/retroarch/0003-Add-hotkey-tap-controller-combo.patch
new file mode 100644
index 0000000..7c2a514
--- /dev/null
+++ b/oldpatches/retroarch/0003-Add-hotkey-tap-controller-combo.patch
@@ -0,0 +1,165 @@
+From dca4ec568ea1aa1b9db479446a9e22627b95a0f1 Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Thu, 8 Jun 2023 15:54:19 +0200
+Subject: [PATCH 2/6] Add hotkey tap controller combo
+
+---
+ input/input_defines.h |  1 +
+ input/input_driver.c  | 49 +++++++++++++++++++++++++++++++++++++++++++
+ intl/msg_hash_us.h    |  4 ++++
+ menu/menu_setting.c   |  3 +++
+ msg_hash.h            |  1 +
+ retroarch.c           | 10 +++++++++
+ 6 files changed, 68 insertions(+)
+
+diff --git a/input/input_defines.h b/input/input_defines.h
+index 75e6768..b428b68 100644
+--- a/input/input_defines.h
++++ b/input/input_defines.h
+@@ -168,6 +168,7 @@ enum input_combo_type
+    INPUT_COMBO_L_R,
+    INPUT_COMBO_HOLD_START,
+    INPUT_COMBO_HOLD_SELECT,
++   INPUT_COMBO_TAP_HOTKEY,
+    INPUT_COMBO_DOWN_SELECT,
+    INPUT_COMBO_L2_R2,
+    INPUT_COMBO_LAST
+diff --git a/input/input_driver.c b/input/input_driver.c
+index 4d76862..46194cc 100644
+--- a/input/input_driver.c
++++ b/input/input_driver.c
+@@ -562,6 +562,8 @@ bool input_driver_button_combo(
+       retro_time_t current_time,
+       input_bits_t* p_input)
+ {
++   static bool last_enable_hotkey_button_state = false;
++   static unsigned enable_hotkey_button_repeat = 0;
+    switch (mode)
+    {
+       case INPUT_COMBO_DOWN_Y_L_R:
+@@ -700,6 +702,53 @@ bool input_driver_button_combo(
+             }
+          }
+          break;
++      case INPUT_COMBO_TAP_HOTKEY:
++         {
++            bool current_enable_hotkey_button_state = BIT256_GET_PTR(p_input, RARCH_ENABLE_HOTKEY);
++
++            /* Pressing other buttons while this key is held down triggers this callback too.
++             * We need to suppress this, otherwise we just end up restarting the timer.
++             * Furthermore RA has a bug that causes a 2-frame button state error that needs working around. */
++            if (last_enable_hotkey_button_state != current_enable_hotkey_button_state)
++            {
++               last_enable_hotkey_button_state = current_enable_hotkey_button_state;
++               enable_hotkey_button_repeat = 1;
++            }
++            else if (enable_hotkey_button_repeat < 3)
++            {
++               enable_hotkey_button_repeat++;
++
++               if (enable_hotkey_button_repeat == 3)
++               {
++                  rarch_timer_t *timer = &input_driver_st.combo_timers[INPUT_COMBO_TAP_HOTKEY];
++
++                  if (!current_enable_hotkey_button_state)
++                  {
++                     /* timer only runs while the enable hotkey is held down */
++                     bool result = timer->timeout_us > 0;
++                     timer->timer_end   = true;
++                     timer->timer_begin = false;
++                     timer->timeout_end = 0;
++                     return result;
++                  }
++
++                  /* User started holding down the hotkey enable button, start the timer */
++                  if (!timer->timer_begin)
++                  {
++                     uint64_t current_usec = cpu_features_get_time_usec();
++                     timer->timeout_us     = 175000;
++                     timer->current        = current_usec;
++                     timer->timeout_end    = timer->current + timer->timeout_us;
++                     timer->timer_begin    = true;
++                     timer->timer_end      = false;
++                  }
++
++                  timer->current           = current_time;
++                  timer->timeout_us        = (timer->timeout_end - timer->current);
++               }
++            }
++         }
++         break;
+       default:
+       case INPUT_COMBO_NONE:
+          break;
+diff --git a/intl/msg_hash_us.h b/intl/msg_hash_us.h
+index bcb0844..3a73e84 100644
+--- a/intl/msg_hash_us.h
++++ b/intl/msg_hash_us.h
+@@ -9937,6 +9937,10 @@ MSG_HASH(
+    MENU_ENUM_LABEL_VALUE_HOLD_SELECT,
+    "Hold Select (2 seconds)"
+    )
++MSG_HASH(
++   MENU_ENUM_LABEL_VALUE_TAP_HOTKEY,
++   "Tap Hotkey (< 175ms down time)"
++   )
+ MSG_HASH(
+    MENU_ENUM_LABEL_VALUE_DOWN_SELECT,
+    "Down + Select"
+diff --git a/menu/menu_setting.c b/menu/menu_setting.c
+index 402630e..1f03cf8 100644
+--- a/menu/menu_setting.c
++++ b/menu/menu_setting.c
+@@ -6560,6 +6560,9 @@ static void setting_get_string_representation_gamepad_combo(
+       case INPUT_COMBO_HOLD_SELECT:
+          strlcpy(s, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_HOLD_SELECT), len);
+          break;
++      case INPUT_COMBO_TAP_HOTKEY:
++         strlcpy(s, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_TAP_HOTKEY), len);
++         break;
+       case INPUT_COMBO_DOWN_SELECT:
+          strlcpy(s, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_DOWN_SELECT), len);
+          break;
+diff --git a/msg_hash.h b/msg_hash.h
+index 2aeb7d6..6ee3ad8 100644
+--- a/msg_hash.h
++++ b/msg_hash.h
+@@ -3857,6 +3857,7 @@ enum msg_hash_enums
+    MENU_ENUM_LABEL_VALUE_L_R,
+    MENU_ENUM_LABEL_VALUE_HOLD_START,
+    MENU_ENUM_LABEL_VALUE_HOLD_SELECT,
++   MENU_ENUM_LABEL_VALUE_TAP_HOTKEY,
+    MENU_ENUM_LABEL_VALUE_DOWN_SELECT,
+    MENU_ENUM_LABEL_VALUE_L2_R2,
+ 
+diff --git a/retroarch.c b/retroarch.c
+index 44ec096..006c932 100644
+--- a/retroarch.c
++++ b/retroarch.c
+@@ -2108,6 +2108,8 @@ bool command_event(enum event_command cmd, void *data)
+    settings_t *settings            = config_get_ptr();
+    recording_state_t *recording_st = recording_state_get_ptr();
+ 
++   bool cancel_hotkey_tap_quit_combo = true;
++
+    switch (cmd)
+    {
+       case CMD_EVENT_SAVE_FILES:
+@@ -4248,6 +4250,14 @@ bool command_event(enum event_command cmd, void *data)
+       /* Deprecated */
+       case CMD_EVENT_SEND_DEBUG_INFO:
+          break;
++
++      default:
++         cancel_hotkey_tap_quit_combo = false;
++   }
++
++   if (cancel_hotkey_tap_quit_combo)
++   {
++      input_state_get_ptr()->combo_timers[INPUT_COMBO_TAP_HOTKEY].timeout_us = 0;
+    }
+ 
+    return true;
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0004-Add-shutdown-hotkey.patch b/oldpatches/retroarch/0004-Add-shutdown-hotkey.patch
new file mode 100644
index 0000000..d7388f9
--- /dev/null
+++ b/oldpatches/retroarch/0004-Add-shutdown-hotkey.patch
@@ -0,0 +1,255 @@
+From 2cb6ca27a22a0e1bfab415c4ecb48af701d8eb46 Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Wed, 12 Jul 2023 18:08:40 +0200
+Subject: [PATCH 3/6] Add shutdown hotkey
+
+---
+ command.h                    |  1 +
+ config.def.keybinds.h        | 21 ++++++++++++
+ configuration.c              |  1 +
+ input/input_defines.h        |  1 +
+ input/input_driver.c         | 25 ++++++++++++++
+ menu/cbs/menu_cbs_sublabel.c |  4 +++
+ runloop.c                    | 66 +++++++++++++++++++++++++++++++++++-
+ runloop.h                    |  1 +
+ 8 files changed, 119 insertions(+), 1 deletion(-)
+
+diff --git a/command.h b/command.h
+index ad3ac3e..d7f93dd 100644
+--- a/command.h
++++ b/command.h
+@@ -448,6 +448,7 @@ static const struct cmd_action_map action_map[] = {
+ static const struct cmd_map map[] = {
+    { "MENU_TOGGLE",            RARCH_MENU_TOGGLE },
+    { "QUIT",                   RARCH_QUIT_KEY },
++   { "SHUTDOWN",               RARCH_SHUTDOWN_KEY },
+    { "CLOSE_CONTENT",          RARCH_CLOSE_CONTENT_KEY },
+    { "RESET",                  RARCH_RESET },
+ 
+diff --git a/config.def.keybinds.h b/config.def.keybinds.h
+index 4ccf902..6067fcd 100644
+--- a/config.def.keybinds.h
++++ b/config.def.keybinds.h
+@@ -298,6 +298,13 @@ static const struct retro_keybind retro_keybinds_1[] = {
+       RARCH_QUIT_KEY, NO_BTN, NO_BTN, 0,
+       true
+    },
++   {
++      NULL, NULL,
++      AXIS_NONE, AXIS_NONE, AXIS_NONE,
++      MENU_ENUM_LABEL_VALUE_SHUTDOWN, RETROK_UNKNOWN,
++      RARCH_SHUTDOWN_KEY, NO_BTN, NO_BTN, 0,
++      true
++   },
+    {
+       NULL, NULL,
+       AXIS_NONE, AXIS_NONE, AXIS_NONE,
+@@ -933,6 +940,13 @@ static const struct retro_keybind retro_keybinds_1[] = {
+       RARCH_QUIT_KEY, NO_BTN, NO_BTN, 0,
+       true
+    },
++   {
++      NULL, NULL,
++      AXIS_NONE, AXIS_NONE, AXIS_NONE,
++      MENU_ENUM_LABEL_VALUE_SHUTDOWN, RETROK_UNKNOWN,
++      RARCH_SHUTDOWN_KEY, NO_BTN, NO_BTN, 0,
++      true
++   },
+    {
+       NULL, NULL,
+       AXIS_NONE, AXIS_NONE, AXIS_NONE,
+@@ -1578,6 +1592,13 @@ static const struct retro_keybind retro_keybinds_1[] = {
+       true
+    },
+ #endif
++   {
++      NULL, NULL,
++      AXIS_NONE, AXIS_NONE, AXIS_NONE,
++      MENU_ENUM_LABEL_VALUE_SHUTDOWN, RETROK_UNKNOWN,
++      RARCH_SHUTDOWN_KEY, NO_BTN, NO_BTN, 0,
++      true
++   },
+    {
+       NULL, NULL,
+       AXIS_NONE, AXIS_NONE, AXIS_NONE,
+diff --git a/configuration.c b/configuration.c
+index c9e4e3c..51248e6 100644
+--- a/configuration.c
++++ b/configuration.c
+@@ -314,6 +314,7 @@ const struct input_bind_map input_config_bind_map[RARCH_BIND_LIST_END_NULL] = {
+ #else
+    DECLARE_META_BIND(2, exit_emulator,         RARCH_QUIT_KEY,               MENU_ENUM_LABEL_VALUE_INPUT_META_QUIT_KEY),
+ #endif
++   DECLARE_META_BIND(2, shutdown,              RARCH_SHUTDOWN_KEY,           MENU_ENUM_LABEL_VALUE_SHUTDOWN),
+    DECLARE_META_BIND(2, close_content,         RARCH_CLOSE_CONTENT_KEY,      MENU_ENUM_LABEL_VALUE_INPUT_META_CLOSE_CONTENT_KEY),
+    DECLARE_META_BIND(2, reset,                 RARCH_RESET,                  MENU_ENUM_LABEL_VALUE_INPUT_META_RESET),
+    DECLARE_META_BIND(1, toggle_fast_forward,   RARCH_FAST_FORWARD_KEY,       MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_KEY),
+diff --git a/input/input_defines.h b/input/input_defines.h
+index b428b68..2aa8a80 100644
+--- a/input/input_defines.h
++++ b/input/input_defines.h
+@@ -77,6 +77,7 @@ enum
+    RARCH_ENABLE_HOTKEY = RARCH_FIRST_META_KEY,
+    RARCH_MENU_TOGGLE,
+    RARCH_QUIT_KEY,
++   RARCH_SHUTDOWN_KEY,
+    RARCH_CLOSE_CONTENT_KEY,
+    RARCH_RESET,
+    RARCH_FAST_FORWARD_KEY,
+diff --git a/input/input_driver.c b/input/input_driver.c
+index 46194cc..34244a5 100644
+--- a/input/input_driver.c
++++ b/input/input_driver.c
+@@ -4154,6 +4154,31 @@ static void input_keys_pressed(
+       }
+    }
+ 
++   if (binds[port][RARCH_SHUTDOWN_KEY].valid)
++   {
++      const struct retro_keybind *shutdown_binds_auto =
++            &input_autoconf_binds[port][RARCH_SHUTDOWN_KEY];
++      const struct retro_keybind *shutdown_normal     =
++            &binds[port][RARCH_SHUTDOWN_KEY];
++
++      /* Allows Shutdown toggle hotkey to still work
++       * even though every hotkey is blocked */
++      if (CHECK_INPUT_DRIVER_BLOCK_HOTKEY(shutdown_normal, shutdown_binds_auto))
++      {
++         if (input_state_wrap(
++               input_st->current_driver,
++               input_st->current_data,
++               input_st->primary_joypad,
++               sec_joypad,
++               joypad_info,
++               &binds[port],
++               input_st->flags & INP_FLAG_KB_MAPPING_BLOCKED,
++               port, RETRO_DEVICE_JOYPAD, 0,
++               RARCH_SHUTDOWN_KEY))
++            input_st->flags &= ~INP_FLAG_BLOCK_HOTKEY;
++      }
++   }
++
+    if (!is_menu && binds[port][RARCH_GAME_FOCUS_TOGGLE].valid)
+    {
+       const struct retro_keybind *focus_binds_auto =
+diff --git a/menu/cbs/menu_cbs_sublabel.c b/menu/cbs/menu_cbs_sublabel.c
+index d8090df..54b54e4 100644
+--- a/menu/cbs/menu_cbs_sublabel.c
++++ b/menu/cbs/menu_cbs_sublabel.c
+@@ -392,6 +392,7 @@ DEFAULT_SUBLABEL_MACRO(action_bind_sublabel_input_meta_restart_key,           ME
+ #else
+ DEFAULT_SUBLABEL_MACRO(action_bind_sublabel_input_meta_quit_key,              MENU_ENUM_SUBLABEL_INPUT_META_QUIT_KEY)
+ #endif
++DEFAULT_SUBLABEL_MACRO(action_bind_sublabel_input_meta_shutdown_key,          MENU_ENUM_SUBLABEL_INPUT_META_QUIT_KEY)
+ DEFAULT_SUBLABEL_MACRO(action_bind_sublabel_input_meta_close_content_key,     MENU_ENUM_SUBLABEL_INPUT_META_CLOSE_CONTENT_KEY)
+ DEFAULT_SUBLABEL_MACRO(action_bind_sublabel_input_meta_reset,                 MENU_ENUM_SUBLABEL_INPUT_META_RESET)
+ 
+@@ -2147,6 +2148,9 @@ int menu_cbs_init_bind_sublabel(menu_file_list_cbs_t *cbs,
+                BIND_ACTION_SUBLABEL(cbs, action_bind_sublabel_input_meta_quit_key);
+ #endif
+                return 0;
++            case RARCH_SHUTDOWN_KEY:
++               BIND_ACTION_SUBLABEL(cbs, action_bind_sublabel_input_meta_shutdown_key);
++               return 0;
+             case RARCH_CLOSE_CONTENT_KEY:
+                BIND_ACTION_SUBLABEL(cbs, action_bind_sublabel_input_meta_close_content_key);
+                return 0;
+diff --git a/runloop.c b/runloop.c
+index 10fb8c2..507065b 100644
+--- a/runloop.c
++++ b/runloop.c
+@@ -5598,6 +5598,70 @@ static enum runloop_state_enum runloop_check_state(
+       }
+    }
+ 
++   /* Check shutdown hotkey */
++   {
++      bool trig_shutdown_key;
++      static bool shutdown_key = false;
++      static bool old_shutdown_key = false;
++      static bool runloop_exec = false;
++      shutdown_key = BIT256_GET(current_bits, RARCH_SHUTDOWN_KEY);
++      trig_shutdown_key = shutdown_key && !old_shutdown_key;
++      old_shutdown_key = shutdown_key;
++
++      if (RUNLOOP_TIME_TO_EXIT(trig_shutdown_key))
++      {
++#ifdef HAVE_SCREENSHOTS
++         unsigned runloop_max_frames = runloop_st->max_frames;
++
++         if ((runloop_max_frames != 0) && (frame_count >= runloop_max_frames) && (runloop_st->flags & RUNLOOP_FLAG_MAX_FRAMES_SCREENSHOT))
++         {
++            const char *screenshot_path = NULL;
++            bool fullpath = false;
++
++            if (string_is_empty(runloop_st->max_frames_screenshot_path))
++               screenshot_path = path_get(RARCH_PATH_BASENAME);
++            else
++            {
++               fullpath = true;
++               screenshot_path = runloop_st->max_frames_screenshot_path;
++            }
++
++            RARCH_LOG("Taking a screenshot before exiting...\n");
++
++            /* Take a screenshot before we exit. */
++            if (!take_screenshot(settings->paths.directory_screenshot, screenshot_path, false, video_driver_cached_frame_has_valid_framebuffer(), fullpath, false))
++            {
++               RARCH_ERR("Could not take a screenshot before exiting.\n");
++            }
++         }
++#endif
++
++         if (runloop_exec)
++            runloop_exec = false;
++
++         if (runloop_st->flags & RUNLOOP_FLAG_CORE_SHUTDOWN_INITIATED)
++         {
++            bool load_dummy_core = false;
++
++            runloop_st->flags &= ~RUNLOOP_FLAG_CORE_SHUTDOWN_INITIATED;
++
++            /* Unload current core */
++            if (!command_event(CMD_EVENT_UNLOAD_CORE, &load_dummy_core))
++            {
++               runloop_st->flags |= RUNLOOP_FLAG_SHUTDOWN_INITIATED;
++            }
++         }
++
++         runloop_st->flags &= ~RUNLOOP_FLAG_CORE_RUNNING;
++
++         old_shutdown_key = shutdown_key;
++
++         runloop_st->shutdown = true;
++
++         return RUNLOOP_STATE_QUIT;
++      }
++   }
++
+ #if defined(HAVE_MENU) || defined(HAVE_GFX_WIDGETS)
+    gfx_animation_update(
+          current_time,
+@@ -6745,7 +6809,7 @@ int runloop_iterate(void)
+       case RUNLOOP_STATE_QUIT:
+          runloop_st->frame_limit_last_time = 0.0;
+          runloop_st->flags                &= ~RUNLOOP_FLAG_CORE_RUNNING;
+-         command_event(CMD_EVENT_QUIT, NULL);
++         command_event(runloop_st->shutdown ? CMD_EVENT_SHUTDOWN : CMD_EVENT_QUIT, NULL);
+          return -1;
+       case RUNLOOP_STATE_POLLED_AND_SLEEP:
+ #ifdef HAVE_NETWORKING
+diff --git a/runloop.h b/runloop.h
+index 3ba255f..9f11115 100644
+--- a/runloop.h
++++ b/runloop.h
+@@ -267,6 +267,7 @@ struct runloop
+ #endif
+ 
+    uint32_t flags;
++   bool shutdown;
+    int8_t run_frames_and_pause;
+ 
+    char runtime_content_path_basename[8192];
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0005-Add-garlicui_run-hooks.patch b/oldpatches/retroarch/0005-Add-garlicui_run-hooks.patch
new file mode 100644
index 0000000..20f8202
--- /dev/null
+++ b/oldpatches/retroarch/0005-Add-garlicui_run-hooks.patch
@@ -0,0 +1,95 @@
+From 45245f676e72277e7c70efbc1ffde5e4307f765e Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Mon, 3 Jul 2023 18:50:42 +0200
+Subject: [PATCH 4/6] Add garlicui_run hooks
+
+---
+ retroarch.c | 51 +++++++++++++++++++++++++++++++++++++++++++++++++--
+ 1 file changed, 49 insertions(+), 2 deletions(-)
+
+diff --git a/retroarch.c b/retroarch.c
+index 006c932..d17c3d6 100644
+--- a/retroarch.c
++++ b/retroarch.c
+@@ -2085,6 +2085,52 @@ bool is_accessibility_enabled(bool accessibility_enable, bool accessibility_enab
+ }
+ #endif
+ 
++/**
++ * @brief Swaps over to GarlicUI and executes the given action.
++ */
++int garlicui_run(const char * action, ...)
++{
++   // The exit code of the child process
++   int exit_code = -1;
++
++   // The argument list
++   const char *args[256] = { "garlicui", NULL };
++
++   // Set the first argument
++   args[1] = action;
++
++   // Initialize variadic arguments
++   va_list arg_list;
++   va_start(arg_list, action);
++
++   // Populate the argument list
++   int i = 2;
++   const char *arg = va_arg(arg_list, const char *);
++   while (arg != NULL && i < 255)
++   {
++      args[i++] = arg;
++      arg = va_arg(arg_list, const char *);
++   }
++
++   // Clean up variadic arguments
++   va_end(arg_list);
++
++   // Wait for pending save state tasks to finish
++   content_wait_for_save_state_task();
++
++   // Shut down the audio driver before swapping the process image (required for Spreadtrum devices)
++   audio_driver_deinit();
++
++   // Quit SDL (to ensure the /dev/fb* descriptor gets closed)
++   SDL_Quit();
++
++   // Replace the current process with the new process
++   execvp(args[0], (char * const*)args);
++
++   // Return the exit code of the child process
++   return exit_code;
++}
++
+ /**
+  * command_event:
+  * @cmd                  : Event command index.
+@@ -2768,6 +2814,7 @@ bool command_event(enum event_command cmd, void *data)
+       case CMD_EVENT_QUIT:
+          if (!retroarch_main_quit())
+             return false;
++         garlicui_run((const char *)data);
+          break;
+       case CMD_EVENT_CHEEVOS_HARDCORE_MODE_TOGGLE:
+ #ifdef HAVE_CHEEVOS
+@@ -3281,7 +3328,7 @@ bool command_event(enum event_command cmd, void *data)
+ #ifdef HAVE_LAKKA
+          system("(sleep 1 && shutdown -P now) & disown");
+ #else
+-         command_event(CMD_EVENT_QUIT, NULL);
++         command_event(CMD_EVENT_QUIT, "shutdown");
+          system("shutdown -P now");
+ #endif /* HAVE_LAKKA */
+ #endif
+@@ -3296,7 +3343,7 @@ bool command_event(enum event_command cmd, void *data)
+ #ifdef HAVE_LAKKA
+          system("(sleep 1 && shutdown -r now) & disown");
+ #else
+-         command_event(CMD_EVENT_QUIT, NULL);
++         command_event(CMD_EVENT_QUIT, "reboot");
+          system("shutdown -r now");
+ #endif /* HAVE_LAKKA */
+ #endif
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0006-Implement-Scaling-Options.patch b/oldpatches/retroarch/0006-Implement-Scaling-Options.patch
new file mode 100644
index 0000000..7172f1c
--- /dev/null
+++ b/oldpatches/retroarch/0006-Implement-Scaling-Options.patch
@@ -0,0 +1,243 @@
+From 18616b30678c46f7f15fa0835293f0bc8a03b9fb Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Sun, 9 Jul 2023 01:44:19 +0200
+Subject: [PATCH 5/6] Implement Scaling Options
+
+---
+ gfx/drivers/sdl_gfx.c                     | 169 ++++++++++++++++++++--
+ libretro-common/include/gfx/video_frame.h |  11 +-
+ 2 files changed, 167 insertions(+), 13 deletions(-)
+
+diff --git a/gfx/drivers/sdl_gfx.c b/gfx/drivers/sdl_gfx.c
+index d015987..e93265b 100644
+--- a/gfx/drivers/sdl_gfx.c
++++ b/gfx/drivers/sdl_gfx.c
+@@ -60,6 +60,14 @@ typedef struct sdl_video
+    sdl_menu_frame_t menu;
+    SDL_Surface *screen;
+ 
++   SDL_Rect system_viewport;
++   SDL_Rect screen_viewport;
++   unsigned system_shift;
++   unsigned screen_shift;
++   bool video_scale_integer;
++   bool video_scale_integer_overscale;
++   unsigned aspect_ratio_idx;
++
+    void *font;
+    const font_renderer_driver_t *font_driver;
+ } sdl_video_t;
+@@ -237,6 +245,140 @@ static void sdl_gfx_set_handles(void)
+ #endif
+ }
+ 
++static void sdl_refresh_viewport(sdl_video_t *vid, unsigned width, unsigned height, unsigned pitch)
++{
++   // Get the settings
++   settings_t *settings = config_get_ptr();
++   vid->video_scale_integer = settings->bools.video_scale_integer;
++   vid->video_scale_integer_overscale = settings->bools.video_scale_integer_overscale;
++   vid->aspect_ratio_idx = settings->uints.video_aspect_ratio_idx;
++
++   // We always start off with a full system viewport
++   vid->system_viewport.x = 0;
++   vid->system_viewport.y = 0;
++   vid->system_viewport.w = width;
++   vid->system_viewport.h = height;
++   vid->system_shift = 0;
++
++   // We have a valid screen surface to work with
++   if (vid->screen)
++   {
++      // We always start off with a full screen viewport
++      vid->screen_viewport.x = 0;
++      vid->screen_viewport.y = 0;
++      vid->screen_viewport.w = vid->screen->w;
++      vid->screen_viewport.h = vid->screen->h;
++      vid->screen_shift = 0;
++
++      // We're trying to do integer scaling
++      if (vid->video_scale_integer)
++      {
++         // Calculate the scaling factor
++         float scale_x = (float)vid->screen_viewport.w / width;
++         float scale_y = (float)vid->screen_viewport.h / height;
++         int scale = scale_x > scale_y ? (int)scale_y : (int)scale_x;
++
++         // We can't underrun 1x scale with integer scaling
++         if (scale < 1)
++         {
++            scale = 1;
++         }
++
++         // We want to overscale
++         if (vid->video_scale_integer_overscale)
++         {
++            scale++;
++         }
++
++         // Update the screen viewport
++         vid->screen_viewport.w = width * scale;
++         vid->screen_viewport.h = height * scale;
++         vid->screen_viewport.x += (vid->screen->w - vid->screen_viewport.w) / 2;
++         vid->screen_viewport.y += (vid->screen->h - vid->screen_viewport.h) / 2;
++
++         // Calculate the next batch of viewport data
++         if (vid->screen_viewport.y < 0)
++         {
++            vid->screen_viewport.y *= (-1);
++            vid->system_viewport.y = height * ((float)vid->screen_viewport.y / vid->screen->h);
++            vid->system_viewport.h -= vid->system_viewport.y << 1;
++            vid->system_shift += vid->system_viewport.y * pitch;
++            vid->screen_viewport.y = 0;
++         }
++         if (vid->screen_viewport.x < 0)
++         {
++            vid->screen_viewport.x *= (-1);
++            vid->system_viewport.x = width * ((float)vid->screen_viewport.x / vid->screen->w);
++            vid->system_viewport.w -= vid->system_viewport.x << 1;
++            vid->system_shift += vid->system_viewport.x * pitch / width;
++            vid->screen_viewport.x = 0;
++         }
++
++         // We can't exceed the screen dimensions
++         if (vid->screen_viewport.w > vid->screen->w)
++         {
++            vid->screen_viewport.w = vid->screen->w;
++         }
++         if (vid->screen_viewport.h > vid->screen->h)
++         {
++            vid->screen_viewport.h = vid->screen->h;
++         }
++      }
++
++      // We want a custom aspect ratio
++      else if (vid->aspect_ratio_idx == ASPECT_RATIO_CUSTOM)
++      {
++         // Get the custom viewport structure
++         const struct video_viewport * custom_viewport = (const struct video_viewport *)video_viewport_get_custom();
++
++         // Set up the screen viewport dimension
++         vid->screen_viewport.w = custom_viewport->width > 0 && custom_viewport->width < vid->screen->w ? custom_viewport->width : vid->screen->w;
++         vid->screen_viewport.h = custom_viewport->height > 0 && custom_viewport->height < vid->screen->h ? custom_viewport->height : vid->screen->h;
++
++         // Calculate the maximum shift in both directions
++         unsigned max_x_shift = vid->screen->w - vid->screen_viewport.w;
++         unsigned max_y_shift = vid->screen->h - vid->screen_viewport.h;
++
++         // Calculate the screen viewport position
++         vid->screen_viewport.x = custom_viewport->x > max_x_shift ? max_x_shift : custom_viewport->x > 0 ? custom_viewport->x : 0;
++         vid->screen_viewport.y = custom_viewport->y > max_y_shift ? max_y_shift : custom_viewport->y > 0 ? custom_viewport->y : 0;
++      }
++
++      // We want a specific aspect ratio
++      else if (vid->aspect_ratio_idx != ASPECT_RATIO_FULL)
++      {
++         // The calculated aspect ratios & delta
++         float delta;
++         float device_aspect = (float)vid->screen_viewport.w / vid->screen_viewport.h;
++         float desired_aspect = video_driver_get_aspect_ratio();
++
++         // The screen size deviates enough from the desired aspect ratio
++         if (fabsf(device_aspect - desired_aspect) >= 0.0001f)
++         {
++            // Calculate the viewport's position & dimension
++            if (device_aspect > desired_aspect)
++            {
++               delta = (desired_aspect / device_aspect - 1.0f) / 2.0f + 0.5f;
++               vid->screen_viewport.x = (int)roundf(vid->screen_viewport.w * (0.5f - delta));
++               vid->screen_viewport.w = (unsigned)roundf(2.0f * vid->screen_viewport.w * delta);
++            }
++            else
++            {
++               delta  = (device_aspect / desired_aspect - 1.0f) / 2.0f + 0.5f;
++               vid->screen_viewport.y = (int)roundf(vid->screen_viewport.h * (0.5f - delta));
++               vid->screen_viewport.h = (unsigned)roundf(2.0f * vid->screen_viewport.h * delta);
++            }
++         }
++      }
++
++      // Calculate the screen viewport shift
++      if (vid->screen_viewport.x != 0 || vid->screen_viewport.y != 0)
++      {
++         vid->screen_shift += (vid->screen_viewport.y * vid->screen->pitch) + (vid->screen_viewport.x * sizeof(uint32_t));
++      }
++   }
++}
++
+ static void *sdl_gfx_init(const video_info_t *video,
+       input_driver_t **input, void **input_data)
+ {
+@@ -372,6 +514,8 @@ static bool sdl_gfx_frame(void *data, const void *frame, unsigned width,
+    if (!vid)
+       return true;
+ 
++   sdl_refresh_viewport(vid, width, height, pitch);
++
+    title[0] = '\0';
+ 
+    video_driver_get_window_title(title, sizeof(title));
+@@ -388,22 +532,29 @@ static bool sdl_gfx_frame(void *data, const void *frame, unsigned width,
+       if (SDL_MUSTLOCK(vid->screen))
+          SDL_LockSurface(vid->screen);
+ 
++      char * system_pixels = (char *)frame + vid->system_shift;
++      char * screen_pixels = (char *)vid->screen->pixels + vid->screen_shift;
++
++      if (vid->video_scale_integer || vid->aspect_ratio_idx != ASPECT_RATIO_FULL)
++      {
++         SDL_FillRect(vid->screen, NULL, SDL_MapRGB(vid->screen->format, 0, 0, 0));
++      }
++
+       video_frame_scale(
+             &vid->scaler,
+-            vid->screen->pixels,
+-            frame,
++            screen_pixels,
++            system_pixels,
+             vid->scaler.in_fmt,
+-            vid->screen->w,
+-            vid->screen->h,
++            vid->screen_viewport.w,
++            vid->screen_viewport.h,
+             vid->screen->pitch,
+-            width,
+-            height,
+-            pitch); 
+-
++            vid->system_viewport.w,
++            vid->system_viewport.h,
++            pitch);
+ 
+       if (SDL_MUSTLOCK(vid->screen))
+          SDL_UnlockSurface(vid->screen);
+-      
++
+       if (msg)
+          sdl_render_msg(vid, vid->screen,
+          msg, vid->screen->w, vid->screen->h, vid->screen->format,
+diff --git a/libretro-common/include/gfx/video_frame.h b/libretro-common/include/gfx/video_frame.h
+index 05ba3f7..cc359f0 100644
+--- a/libretro-common/include/gfx/video_frame.h
++++ b/libretro-common/include/gfx/video_frame.h
+@@ -82,10 +82,13 @@ static INLINE void video_frame_scale(
+       unsigned pitch)
+ {
+    if (
+-            width  != (unsigned)scaler->in_width
+-         || height != (unsigned)scaler->in_height
+-         || format != scaler->in_fmt
+-         || pitch  != (unsigned)scaler->in_stride
++            width         != (unsigned)scaler->in_width
++         || height        != (unsigned)scaler->in_height
++         || format        != scaler->in_fmt
++         || pitch         != (unsigned)scaler->in_stride
++         || scaler_width  != (unsigned)scaler->out_width
++         || scaler_height != (unsigned)scaler->out_height
++         || scaler_pitch  != (unsigned)scaler->out_stride
+       )
+    {
+       scaler->in_fmt    = format;
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0007-Ignore-NULL-frames.patch b/oldpatches/retroarch/0007-Ignore-NULL-frames.patch
new file mode 100644
index 0000000..f5c7053
--- /dev/null
+++ b/oldpatches/retroarch/0007-Ignore-NULL-frames.patch
@@ -0,0 +1,25 @@
+From 047d10c2685ee7133634a971e6ff02955064579b Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Sat, 15 Jul 2023 23:08:26 +0200
+Subject: [PATCH 6/6] Ignore NULL frames
+
+---
+ gfx/drivers/sdl_gfx.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/gfx/drivers/sdl_gfx.c b/gfx/drivers/sdl_gfx.c
+index e93265b..2da5077 100644
+--- a/gfx/drivers/sdl_gfx.c
++++ b/gfx/drivers/sdl_gfx.c
+@@ -511,7 +511,7 @@ static bool sdl_gfx_frame(void *data, const void *frame, unsigned width,
+    bool menu_is_alive                  = video_info->menu_is_alive;
+ #endif
+ 
+-   if (!vid)
++   if (!vid || !frame)
+       return true;
+ 
+    sdl_refresh_viewport(vid, width, height, pitch);
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0008-Write-auto-savestate-thumbnails-synchronously.patch b/oldpatches/retroarch/0008-Write-auto-savestate-thumbnails-synchronously.patch
new file mode 100644
index 0000000..a7e8143
--- /dev/null
+++ b/oldpatches/retroarch/0008-Write-auto-savestate-thumbnails-synchronously.patch
@@ -0,0 +1,28 @@
+From 68bf0d81269bedb62d3aac949cd1f6e63ee9b9d0 Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Fri, 21 Jul 2023 19:27:10 +0200
+Subject: [PATCH] Write auto savestate thumbnails synchronously
+
+---
+ tasks/task_screenshot.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/tasks/task_screenshot.c b/tasks/task_screenshot.c
+index 2cd3bab..acf6364 100644
+--- a/tasks/task_screenshot.c
++++ b/tasks/task_screenshot.c
+@@ -365,7 +365,10 @@ static bool screenshot_dump(
+    state->out_buffer     = buf;
+ #endif
+ 
+-   if (use_thread)
++   const char * auto_suffix = ".auto";
++   bool is_auto_state = strlen(name_base) >= strlen(auto_suffix) && strcmp(name_base + strlen(name_base) - strlen(auto_suffix), auto_suffix) == 0;
++
++   if (use_thread && !is_auto_state)
+    {
+       retro_task_t *task = task_init();
+ 
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/0009-Don-t-restart-MMAP-soundcards.patch b/oldpatches/retroarch/0009-Don-t-restart-MMAP-soundcards.patch
new file mode 100644
index 0000000..82d4c9e
--- /dev/null
+++ b/oldpatches/retroarch/0009-Don-t-restart-MMAP-soundcards.patch
@@ -0,0 +1,138 @@
+From f58836b69d06d319b8436a997e5dacd314c6c323 Mon Sep 17 00:00:00 2001
+From: Black-Seraph <admin@black-seraph.com>
+Date: Fri, 4 Aug 2023 17:22:28 +0200
+Subject: [PATCH] Don't restart MMAP soundcards
+
+---
+ audio/drivers/tinyalsa.c | 27 +++++++++++++++++-------
+ retroarch.c              | 45 +++++++++++++++++++++++++++++++++-------
+ 2 files changed, 56 insertions(+), 16 deletions(-)
+
+diff --git a/audio/drivers/tinyalsa.c b/audio/drivers/tinyalsa.c
+index 7cf458d..a7324d1 100644
+--- a/audio/drivers/tinyalsa.c
++++ b/audio/drivers/tinyalsa.c
+@@ -113,12 +113,13 @@ static void * tinyalsa_init(const char *devicestr, unsigned rate, unsigned laten
+ 	tinyalsa->config.channels = 2;
+ 	tinyalsa->config.period_size = period_size;
+ 	tinyalsa->config.period_count = 4;
+-	tinyalsa->config.start_threshold = tinyalsa->config.period_size;
+-	tinyalsa->config.stop_threshold = 0;
+-	tinyalsa->config.silence_threshold = tinyalsa->config.period_size * tinyalsa->config.period_count;
+-	tinyalsa->config.silence_size = 0;
++	tinyalsa->config.start_threshold = tinyalsa->config.period_size * tinyalsa->config.period_count;//160;//tinyalsa->config.period_size;
++	tinyalsa->config.stop_threshold = -1;
++	tinyalsa->config.silence_threshold = 0;
++	tinyalsa->config.silence_size = -1;
++	tinyalsa->config.avail_min = tinyalsa->config.period_size;
+ 
+-	tinyalsa->pcm = pcm_open(card, device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP : 0), &tinyalsa->config);
++	tinyalsa->pcm = pcm_open(card, device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP | PCM_NOIRQ | PCM_MONOTONIC | PCM_NORESTART : 0), &tinyalsa->config);
+ 
+ 	if (!tinyalsa->pcm)
+ 	{
+@@ -140,7 +141,7 @@ static void * tinyalsa_init(const char *devicestr, unsigned rate, unsigned laten
+ 	if (latency < (unsigned int)initial_latency)
+ 	{
+ 		RARCH_WARN("[TINYALSA]: Cannot have a latency less than %ums. Defaulting to 64ms.\n", (unsigned int)initial_latency);
+-		latency = 64;
++		latency = initial_latency;
+ 	}
+ 
+ 	latency -= (unsigned int)initial_latency;
+@@ -185,7 +186,17 @@ static ssize_t tinyalsa_write(void *data, const void *buf_, size_t size_)
+ 
+ 			if (frames < 0)
+ 			{
+-				continue;
++				if (errno == EAGAIN)
++				{
++					if (tinyalsa->nonblock)
++					{
++						break;
++					}
++
++					continue;
++				}
++
++				break;
+ 			}
+ 
+ 			written += frames;
+@@ -203,7 +214,7 @@ static bool tinyalsa_start(void *data, bool is_shutdown)
+ 
+ 	while (tinyalsa->pcm == NULL)
+ 	{
+-		tinyalsa->pcm = (int *)pcm_open(tinyalsa->card, tinyalsa->device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP : 0), &tinyalsa->config);
++		tinyalsa->pcm = (int *)pcm_open(tinyalsa->card, tinyalsa->device, PCM_OUT | PCM_NONBLOCK | (tinyalsa->use_mmap ? PCM_MMAP | PCM_NOIRQ | PCM_MONOTONIC | PCM_NORESTART : 0), &tinyalsa->config);
+ 	}
+ 
+ 	return tinyalsa->pcm != NULL;
+diff --git a/retroarch.c b/retroarch.c
+index d17c3d6..d6f10fc 100644
+--- a/retroarch.c
++++ b/retroarch.c
+@@ -2088,11 +2088,8 @@ bool is_accessibility_enabled(bool accessibility_enable, bool accessibility_enab
+ /**
+  * @brief Swaps over to GarlicUI and executes the given action.
+  */
+-int garlicui_run(const char * action, ...)
++void garlicui_run(const char * action, ...)
+ {
+-   // The exit code of the child process
+-   int exit_code = -1;
+-
+    // The argument list
+    const char *args[256] = { "garlicui", NULL };
+ 
+@@ -2124,11 +2121,43 @@ int garlicui_run(const char * action, ...)
+    // Quit SDL (to ensure the /dev/fb* descriptor gets closed)
+    SDL_Quit();
+ 
+-   // Replace the current process with the new process
+-   execvp(args[0], (char * const*)args);
++   // Open the command file
++   FILE * command_file = fopen("/tmp/command", "w");
+ 
+-   // Return the exit code of the child process
+-   return exit_code;
++   // We managed to open the command file
++   if (command_file != NULL)
++   {
++      // Iterate all arguments
++      for (int i = 0; args[i] != NULL; i++)
++      {
++         // The argument contains whitespaces
++         if (strchr(args[i], ' ') != NULL)
++         {
++            // Write the argument to the file
++            fprintf(command_file, "\"%s\"", args[i]);
++         }
++
++         // The argument doesn't contain whitespaces
++         else
++         {
++            // Write the argument to the file
++            fprintf(command_file, "%s", args[i]);
++         }
++
++         // We haven't reached the last argument yet
++         if (args[i + 1] != NULL)
++         {
++            // Which means we need a space separator
++            fprintf(command_file, " ");
++         }
++      }
++
++      // Close the command file
++      fclose(command_file);
++
++      // Exit the application
++      exit(0);
++   }
+ }
+ 
+ /**
+-- 
+2.25.1
+
diff --git a/oldpatches/retroarch/Config.in b/oldpatches/retroarch/Config.in
new file mode 100644
index 0000000..edb9725
--- /dev/null
+++ b/oldpatches/retroarch/Config.in
@@ -0,0 +1,153 @@
+menuconfig BR2_PACKAGE_RETROARCH
+	bool "retroarch"
+	help
+	  RetroArch is the reference frontend for the libretro API.
+	  Popular examples of implementations for this API includes
+	  video game system emulators and game engines as well as
+	  more generalized 3D programs. These programs are
+	  instantiated as dynamic libraries.
+	  We refer to these as "libretro cores".
+
+	  https://github.com/libretro/RetroArch
+
+if BR2_PACKAGE_RETROARCH
+comment "features"
+
+config BR2_PACKAGE_RETROARCH_FFMPEG
+	bool "FFMPEG support"
+	depends on BR2_PACKAGE_FFMPEG_ARCH_SUPPORTS
+	select BR2_PACKAGE_FFMPEG
+	select BR2_PACKAGE_FFMPEG_GPL
+	select BR2_PACKAGE_FFMPEG_SWSCALE
+	help
+	  Video/music player implemented in libretro.
+
+config BR2_PACKAGE_RETROARCH_EGL
+	bool "EGL support"
+	depends on BR2_TOOLCHAIN_HAS_THREADS # libdrm
+	depends on BR2_PACKAGE_MESA3D_OPENGL_EGL
+	depends on BR2_PACKAGE_XORG7
+	select BR2_PACKAGE_XLIB_LIBXXF86VM
+	help
+	  KMS (Kernel Mode Setting) mode is a feature where RetroArch
+	  can use the OpenGL driver outside Xorg, running straight in
+	  the virtual terminal. It is a fairly obscure feature, but
+	  very powerful in a console scenario.
+
+comment "EGL support needs an OpenGL EGL backend provided by mesa3d"
+	depends on BR2_PACKAGE_XORG7
+	depends on !BR2_PACKAGE_MESA3D_OPENGL_EGL
+
+config BR2_PACKAGE_RETROARCH_GLES
+	bool "GLES support"
+	depends on BR2_TOOLCHAIN_HAS_THREADS # libdrm
+	depends on BR2_PACKAGE_MESA3D_OPENGL_ES
+	depends on BR2_PACKAGE_XORG7
+	select BR2_PACKAGE_XLIB_LIBXXF86VM
+	help
+	  KMS (Kernel Mode Setting) mode is a feature where RetroArch
+	  can use the OpenGL driver outside Xorg, running straight in
+	  the virtual terminal. It is a fairly obscure feature, but
+	  very powerful in a console scenario.
+
+comment "GLES support needs an OpenGLES backend provided by mesa3d"
+	depends on BR2_PACKAGE_XORG7
+	depends on !BR2_PACKAGE_MESA3D_OPENGL_ES
+
+config BR2_PACKAGE_RETROARCH_KMS
+	bool "KMS support"
+	depends on BR2_TOOLCHAIN_HAS_THREADS # libdrm
+	select BR2_PACKAGE_LIBDRM
+	help
+	  KMS (Kernel Mode Setting) mode is a feature where RetroArch
+	  can use the OpenGL driver outside Xorg, running straight in
+	  the virtual terminal. It is a fairly obscure feature, but
+	  very powerful in a console scenario.
+
+comment "KMS support needs an OpenGL EGL backend provided by mesa3d"
+	depends on !BR2_PACKAGE_MESA3D_OPENGL_EGL
+
+config BR2_PACKAGE_RETROARCH_QT5
+	bool "Qt5 support"
+	depends on BR2_PACKAGE_QT5
+	select BR2_PACKAGE_QT5BASE
+	select BR2_PACKAGE_QT5BASE_GUI
+	select BR2_PACKAGE_QT5BASE_WIDGETS
+	select BR2_PACKAGE_QT5BASE_CONCURRENT
+	select BR2_PACKAGE_OPENSSL # Uses QSslError
+
+config BR2_PACKAGE_RETROARCH_SDL
+	bool "SDL support"
+	select BR2_PACKAGE_SDL
+	help
+	  SDL input/audio/video drivers
+
+config BR2_PACKAGE_RETROARCH_SDL2
+	bool "SDL2 support"
+	depends on BR2_PACKAGE_XORG7
+	depends on !BR2_PACKAGE_RETROARCH_SDL
+	depends on !BR2_STATIC_LIBS
+	select BR2_PACKAGE_SDL2
+	select BR2_PACKAGE_SDL2_X11
+	help
+	  SDL2 input/audio/video drivers
+
+comment "sdl2 support needs a toolchain w/ dynamic library"
+	depends on BR2_STATIC_LIBS
+
+config BR2_PACKAGE_RETROARCH_V4L2
+	bool "V4L2 support"
+	depends on BR2_TOOLCHAIN_HAS_THREADS
+	depends on BR2_INSTALL_LIBSTDCPP
+	depends on BR2_TOOLCHAIN_HEADERS_AT_LEAST_3_0 # media headers
+	select BR2_PACKAGE_LIBV4L
+	help
+	  Libretro core for V4L2 capture devices
+	  The basic idea is this: Plug your legacy console into a
+	  capture device and use RetroArch to upscale it and apply
+	  shaders to taste.
+
+comment "V4l2 support needs a toolchain w/ threads, C++ and headers >= 3.0"
+	depends on !BR2_TOOLCHAIN_HAS_THREADS \
+		|| !BR2_INSTALL_LIBSTDCPP || !BR2_TOOLCHAIN_HEADERS_AT_LEAST_3_0
+
+config BR2_PACKAGE_RETROARCH_WAYLAND
+	bool "Wayland support"
+	depends on BR2_PACKAGE_HAS_LIBEGL_WAYLAND
+	depends on BR2_TOOLCHAIN_HEADERS_AT_LEAST_3_17
+	select BR2_PACKAGE_WAYLAND
+	select BR2_PACKAGE_WAYLAND_PROTOCOLS
+	select BR2_PACKAGE_LIBXKBCOMMON
+	help
+	  Wayland video driver
+
+comment "Wayland support needs an OpenGL EGL backend provided by mesa3d w/ headers >= 3.17"
+	depends on !BR2_PACKAGE_MESA3D_OPENGL_EGL || \
+		!BR2_TOOLCHAIN_HEADERS_AT_LEAST_3_17
+
+config BR2_PACKAGE_RETROARCH_XVIDEO
+	bool "Xvideo support"
+	depends on BR2_PACKAGE_XORG7
+	select BR2_PACKAGE_XLIB_LIBXV
+	help
+	  Xvideo support
+
+comment "Menus"
+
+config BR2_PACKAGE_RETROARCH_RGUI_MENU
+	bool "RGUI"
+
+config BR2_PACKAGE_RETROARCH_MATERIAUI_MENU
+	bool "MateriaUI"
+
+config BR2_PACKAGE_RETROARCH_XMB_MENU
+	bool "XMB"
+
+config BR2_PACKAGE_RETROARCH_OZONE_MENU
+	bool "Ozone"
+
+endif
+
+comment "retroarch needs a toolchain w/ dynamic library, threads, wchar"
+	depends on BR2_USE_MMU
+	depends on BR2_STATIC_LIBS || !BR2_TOOLCHAIN_HAS_THREADS || !BR2_USE_WCHAR
diff --git a/oldpatches/retroarch/Internal Gamepad.cfg b/oldpatches/retroarch/Internal Gamepad.cfg
new file mode 100644
index 0000000..57c8439
--- /dev/null
+++ b/oldpatches/retroarch/Internal Gamepad.cfg	
@@ -0,0 +1,43 @@
+input_driver = "sdl"
+input_device = "Internal Gamepad"
+input_b_btn = "1"
+input_y_btn = "5"
+input_select_btn = "9"
+input_start_btn = "10"
+input_up_btn = "h0up"
+input_down_btn = "h0down"
+input_left_btn = "h0left"
+input_right_btn = "h0right"
+input_a_btn = "2"
+input_x_btn = "4"
+input_l_btn = "7"
+input_r_btn = "8"
+input_l2_axis = "+2"
+input_r2_axis = "+5"
+input_l3_btn = "12"
+input_r3_btn = "13"
+input_l_x_plus_axis = "+0"
+input_l_x_minus_axis = "-0"
+input_l_y_plus_axis = "+1"
+input_l_y_minus_axis = "-1"
+input_r_x_plus_axis = "+3"
+input_r_x_minus_axis = "-3"
+input_r_y_plus_axis = "+4"
+input_r_y_minus_axis = "-4"
+input_audio_mute_btn = "h0down"
+input_cheat_toggle_btn = "2"
+input_disk_next_btn = "5"
+input_disk_prev_btn = "1"
+input_enable_hotkey_btn = "11"
+input_fps_toggle_btn = "9"
+input_load_state_axis = "+2"
+input_menu_toggle_btn = "4"
+input_pause_toggle_btn = "10"
+input_quit_gamepad_combo = "9"
+input_save_state_axis = "+5"
+input_screenshot_btn = "h0up"
+input_state_slot_decrease_btn = "h0left"
+input_state_slot_increase_btn = "h0right"
+input_toggle_fast_forward_btn = "8"
+input_toggle_slowmotion_btn = "7"
+input_shutdown_btn = "0"
diff --git a/oldpatches/retroarch/retroarch.mk b/oldpatches/retroarch/retroarch.mk
new file mode 100644
index 0000000..b880299
--- /dev/null
+++ b/oldpatches/retroarch/retroarch.mk
@@ -0,0 +1,219 @@
+################################################################################
+#
+# retroarch
+#
+################################################################################
+
+RETROARCH_VERSION = 04833f54b5d7b037ac1d8f8a5b9a36fb8b6ddf0c
+RETROARCH_SITE = https://github.com/libretro/RetroArch.git
+RETROARCH_SITE_METHOD = git
+RETROARCH_LICENSE = GPL-3.0
+RETROARCH_LICENSE_FILES = COPYING
+RETROARCH_DEPENDENCIES = host-pkgconf
+
+RETROARCH_CONFIG_OPTS = \
+	--build=x86_64-linux \
+	--prefix=$(TARGET_DIR)/usr \
+	--sysconfdir=$(STAGING_DIR) \
+	--host=$(TARGET_CC) \
+	--disable-gdi \
+	--disable-d3dx \
+	--disable-d3d8 \
+	--disable-d3d9 \
+	--disable-d3d10 \
+	--disable-d3d11 \
+	--disable-d3d12 \
+	--disable-metal \
+	--disable-opengl1 \
+	--enable-rpng
+
+ifeq ($(BR2_PACKAGE_ALSA_LIB),y)
+RETROARCH_DEPENDENCIES += alsa-lib
+RETROARCH_CONFIG_OPTS += --enable-alsa
+else
+RETROARCH_CONFIG_OPTS += --disable-alsa
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_OPENSSL),y)
+RETROARCH_DEPENDENCIES += openssl
+RETROARCH_CONFIG_OPTS += --enable-ssl
+else
+RETROARCH_CONFIG_OPTS += --disable-ssl
+endif
+
+ifeq ($(BR2_PACKAGE_PULSEAUDIO),y)
+RETROARCH_DEPENDENCIES += pulseaudio
+RETROARCH_CONFIG_OPTS += --enable-pulse
+else
+RETROARCH_CONFIG_OPTS += --disable-pulse
+endif
+
+ifeq ($(BR2_PACKAGE_TINYALSA),y)
+RETROARCH_DEPENDENCIES += tinyalsa
+RETROARCH_CONFIG_OPTS += --enable-tinyalsa
+else
+RETROARCH_CONFIG_OPTS += --disable-tinyalsa
+endif
+
+ifeq ($(BR2_PACKAGE_JACK2),y)
+RETROARCH_DEPENDENCIES += jack2
+RETROARCH_CONFIG_OPTS += --enable-jack
+else
+RETROARCH_CONFIG_OPTS += --disable-jack
+endif
+
+ifeq ($(BR2_PACKAGE_HAS_EUDEV),y)
+RETROARCH_DEPENDENCIES += eudev
+RETROARCH_CONFIG_OPTS += --enable-udev
+else
+RETROARCH_CONFIG_OPTS += --disable-udev
+endif
+
+ifeq ($(BR2_PACKAGE_HAS_UDEV),y)
+RETROARCH_CONFIG_OPTS += --enable-udev
+else
+RETROARCH_CONFIG_OPTS += --disable-udev
+endif
+
+ifeq ($(BR2_PACKAGE_SYSTEMD),y)
+RETROARCH_DEPENDENCIES += systemd
+RETROARCH_CONFIG_OPTS += --enable-systemd
+else
+RETROARCH_CONFIG_OPTS += --disable-systemd
+endif
+
+ifeq ($(BR2_PACKAGE_MESA3D_OPENGL_GLX),y)
+RETROARCH_CONFIG_OPTS += --enable-opengl
+RETROARCH_DEPENDENCIES += mesa3d
+else
+RETROARCH_CONFIG_OPTS += --disable-opengl
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_EGL),y)
+RETROARCH_CONFIG_OPTS += --enable-egl
+RETROARCH_DEPENDENCIES += mesa3d xlib_libXxf86vm
+else
+RETROARCH_CONFIG_OPTS += --disable-egl
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_GLES),y)
+RETROARCH_CONFIG_OPTS += --enable-opengles
+RETROARCH_DEPENDENCIES += mesa3d
+else
+RETROARCH_CONFIG_OPTS += --disable-opengles
+endif
+
+ifeq ($(BR2_PACKAGE_ZLIB),y)
+RETROARCH_DEPENDENCIES += libzlib
+RETROARCH_CONFIG_OPTS += --enable-zlib
+else
+RETROARCH_CONFIG_OPTS += --disable-zlib
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_FFMPEG),y)
+RETROARCH_DEPENDENCIES += ffmpeg
+RETROARCH_CONFIG_OPTS += --enable-ffmpeg
+else
+RETROARCH_CONFIG_OPTS += --disable-ffmpeg
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_QT5),y)
+RETROARCH_CONFIG_OPTS += --enable-qt
+RETROARCH_DEPENDENCIES += qt5base
+else
+RETROARCH_CONFIG_OPTS += --disable-qt
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_KMS),y)
+RETROARCH_CONFIG_OPTS += --enable-kms
+RETROARCH_DEPENDENCIES += mesa3d libdrm
+else
+RETROARCH_CONFIG_OPTS += --disable-kms
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_SDL),y)
+RETROARCH_CONFIG_OPTS += --enable-sdl
+RETROARCH_DEPENDENCIES += sdl
+else
+RETROARCH_CONFIG_OPTS += --disable-sdl
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_SDL2),y)
+RETROARCH_CONFIG_OPTS += --enable-sdl2
+RETROARCH_DEPENDENCIES += sdl2
+else
+RETROARCH_CONFIG_OPTS += --disable-sdl2
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_WAYLAND),y)
+RETROARCH_CONFIG_OPTS += --enable-wayland
+RETROARCH_DEPENDENCIES += mesa3d
+else
+RETROARCH_CONFIG_OPTS += --disable-wayland
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_V4L2),y)
+RETROARCH_DEPENDENCIES += libv4l
+RETROARCH_CONFIG_OPTS += --enable-v4l2
+else
+RETROARCH_CONFIG_OPTS += --disable-v4l2
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_XVIDEO),y)
+RETROARCH_CONFIG_OPTS += --enable-xvideo
+RETROARCH_DEPENDENCIES += xlib_libXv
+else
+RETROARCH_CONFIG_OPTS += --disable-xvideo
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_RGUI_MENU),y)
+RETROARCH_CONFIG_OPTS += --enable-rgui
+else
+RETROARCH_CONFIG_OPTS += --disable-rgui
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_MATERIAUI_MENU),y)
+RETROARCH_CONFIG_OPTS += --enable-materialui
+else
+RETROARCH_CONFIG_OPTS += --disable-materialui
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_XMB_MENU),y)
+RETROARCH_CONFIG_OPTS += --enable-xmb
+else
+RETROARCH_CONFIG_OPTS += --disable-xmb
+endif
+
+ifeq ($(BR2_PACKAGE_RETROARCH_OZONE_MENU),y)
+RETROARCH_CONFIG_OPTS += --enable-ozone
+else
+RETROARCH_CONFIG_OPTS += --disable-ozone
+endif
+
+define RETROARCH_CONFIGURE_CMDS
+	cd $(@D) && \
+	PKG_CONF_PATH=pkg-config \
+	PKG_CONFIG_PATH="$(HOST_PKG_CONFIG_PATH)" \
+	$(TARGET_CONFIGURE_OPTS) \
+	$(TARGET_CONFIGURE_ARGS) \
+	CROSS_COMPILE="$(TARGET_CROSS)" \
+	LDFLAGS="-ltinyalsa" \
+	./configure $(RETROARCH_CONFIG_OPTS)
+endef
+
+define RETROARCH_BUILD_CMDS
+	$(TARGET_MAKE_ENV) $(TARGET_CONFIGURE_ARGS) $(MAKE) -C $(@D)
+	$(TARGET_MAKE_ENV) compiler=$(TARGET_CC) $(MAKE) -C $(@D)/libretro-common/audio/dsp_filters
+	$(TARGET_MAKE_ENV) compiler=$(TARGET_CC) $(MAKE) -C $(@D)/gfx/video_filters
+endef
+
+define RETROARCH_INSTALL_TARGET_CMDS
+	mkdir -p $(TARGET_DIR)/root/.config/retroarch/autoconfig
+	$(TARGET_MAKE_ENV) $(MAKE) -C $(@D) install
+	$(TARGET_MAKE_ENV) $(MAKE) PREFIX=$(TARGET_DIR) -C $(@D)/libretro-common/audio/dsp_filters install
+	$(TARGET_MAKE_ENV) $(MAKE) PREFIX=$(TARGET_DIR) -C $(@D)/gfx/video_filters install
+	$(INSTALL) -m 0644 -D $(RETROARCH_PKGDIR)/retroarch.cfg $(TARGET_DIR)/root/.config/retroarch/retroarch.cfg
+	$(INSTALL) -m 0644 -D "$(RETROARCH_PKGDIR)/Internal Gamepad.cfg" "$(TARGET_DIR)/root/.config/retroarch/autoconfig/Internal Gamepad.cfg"
+endef
+
+$(eval $(generic-package))
-- 
2.25.1

